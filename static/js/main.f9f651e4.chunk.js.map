{"version":3,"sources":["../node_modules/jsclass/src sync","assets/images/dropdown.svg","assets/images/dropup.svg","configs/theme/config-styles.scss","utils/bignumber.ts","theme/components.js","theme/index.js","utils/helpers.tsx","provider/UncheckedJsonRpcSigner.ts","stores/actions/actions.ts","provider/Web3Window.ts","provider/connectors.ts","stores/Provider.ts","stores/Transaction.ts","stores/SwapForm.ts","stores/Token.ts","utils/balancerCalcs.ts","stores/Proxy.ts","stores/Error.ts","stores/BlockchainFetch.ts","stores/Dropdown.ts","configs/config-main.ts","configs/theme/config-theme.ts","configs/theme/lib-style-helpers.ts","configs/addresses.ts","stores/actions/fetch.ts","stores/ContractMetadata.ts","stores/AppSettings.ts","utils/CostCalculator.ts","stores/Sor.ts","utils/poolsBackup.ts","utils/subGraph.ts","stores/Pool.ts","stores/AssetOptions.ts","stores/Root.ts","contexts/storesContext.tsx","utils/helperHooks.jsx","components/Web3ReactManager/index.jsx","components/WalletDropdown/Transaction.js","components/WalletDropdown/TransactionPanel.tsx","components/WalletDropdown/index.js","components/Identicon/index.js","components/Button.tsx","components/Wallet/index.jsx","components/Header/index.tsx","components/GeneralNotification.tsx","components/TokenPanel.tsx","components/BuyToken.tsx","components/SellToken.tsx","components/Switch.tsx","components/ErrorDisplay.tsx","components/SlippageInfo.tsx","components/SlippageSelector.tsx","components/TradeComposition.tsx","components/AssetOptions.tsx","components/AssetSelector.tsx","components/SwapForm.tsx","App.tsx","serviceWorker.js","index.tsx","assets/images/circle.svg"],"names":["webpackEmptyContext","req","e","Error","code","keys","resolve","module","exports","id","BigNumber","config","EXPONENTIAL_AT","ROUNDING_MODE","ROUND_HALF_EVEN","DECIMAL_PLACES","styled","button","attrs","warning","theme","backgroundColor","salmonRed","royalBlue","white","darken","concreteGray","silverGray","a","target","rel","input","textColor","inputBackground","chaliceGray","rotate","keyframes","img","MEDIA_WIDTHS","upToSmall","upToMedium","upToLarge","Object","reduce","accumulator","size","css","createGlobalStyle","utils","bigNumberify","MAX_UINT","ethers","constants","MaxUint256","toChecksum","address","getAddress","bnum","val","toString","scale","decimalPlaces","scalePow","scaleMul","pow","times","fromWei","formatEther","toAddressStub","start","slice","end","isEmpty","str","length","isAddress","value","toLowerCase","ETHERSCAN_PREFIXES","1","3","4","5","42","getEtherscanLink","networkId","data","type","prefix","formatBalanceTruncated","balance","decimals","precision","truncateAt","result","formatBalance","substring","eq","toFixed","ROUND_DOWN","padToDecimalPlaces","minDecimals","split","UncheckedJsonRpcSigner","signer","defineReadOnly","provider","this","transaction","sendUncheckedTransaction","then","hash","nonce","gasLimit","gasPrice","chainId","confirmations","from","wait","waitForTransaction","message","signMessage","preLog","params","console","log","action","contract","sender","overrides","sendAction","actionResponse","txResponse","undefined","error","web3Window","window","providerOptions","walletconnect","package","WalletConnectProvider","options","infuraId","process","REACT_APP_INFURA_ID","portis","Portis","web3Modal","Web3Modal","background","main","secondary","border","hover","supportedChainId","Number","getSupportedChainId","chainNameById","isChainIdSupported","backupUrls","REACT_APP_SUBGRAPH_URL_1","REACT_APP_SUBGRAPH_URL_3","REACT_APP_SUBGRAPH_URL_42","ContractTypes","ERRORS","schema","BPool","require","abi","BFactory","TestToken","ExchangeProxy","Multicall","TestTokenBytes","FetchCode","ProviderStore","rootStore","chainData","currentBlockNumber","providerStatus","active","injectedLoaded","injectedActive","backUpLoaded","activeProvider","handleNetworkChanged","bind","handleClose","handleAccountsChanged","connect","loadWeb3","blockNumber","library","account","debug","getSigner","signerAccount","Contract","getProviderOrSigner","blockchainFetchStore","blockchainFetch","accounts","on","removeListener","close","web3","providers","Web3Provider","isMetaMask","autoRefreshOnNetworkChange","getNetwork","network","listAccounts","injectedChainId","injectedWeb3","ethereum","loadProvider","JsonRpcProvider","activeChainId","backUpWeb3","NoWeb3","fetchUserBlockchainData","observable","transactionStore","tokenStore","contractMetadataStore","swapFormStore","checkPendingTransactions","fetchBalancerTokenData","getTrackedTokenAddresses","updateSelectedTokenMetaData","contractType","contractAddress","BlockchainActionNoAccount","BlockchainActionNoChainId","getContract","response","warn","addTransactionRecord","BlockchainActionNoResponse","SwapMethods","SwapObjection","InputValidationStatus","ModalType","TransactionStore","txRecords","filter","isTxPending","getPendingTransactions","providerStore","poolStore","currentBlock","getCurrentBlockNumber","forEach","isStale","getTransactionReceipt","receipt","blockNumberChecked","loadPoolsList","catch","SUCCESS","record","txHash","records","find","push","txRecord","tokenAbi","TokenStore","getAllowance","tokenAddress","spender","chainApprovals","allowances","tokenApprovals","userApprovals","allowance","fetchOnChainTokenMetadata","proxyAddress","getProxyAddress","tokenMetadata","symbol","name","hasIcon","balanceBn","balanceFormatted","getBalance","balanceWei","tokenContract","tokenDecimals","tokenSymbol","tokenName","tokenContractBytes","tokenSymbolBytes","parseBytes32String","tokenNameBytes","getWhiteListedTokenPrecision","getTokenBalance","allowanceOnChain","balances","contractMetadata","tokens","userBalances","owner","lastFetched","approvals","fetchBlock","approval","index","isAllowanceFetched","isAllowanceStale","chainBalances","fetchedBalances","isBalanceFetched","isBalanceStale","tokenBalances","tokenAddr","setTokenDecimals","whiteListedBalanceBn","balanceOf","sendTransaction","helpers","tokensToTrack","promises","balanceCalls","allowanceCalls","decimalsCalls","tokenList","multiAddress","getMultiAddress","multi","iface","Interface","functions","encode","aggregate","getEthBalance","Promise","all","balBlock","mulBalance","allBlock","mulAllowance","mulEth","mulDecimals","map","decode","ethBalance","unshift","decimalsList","toNumber","setAllowances","setDecimals","setBalances","FAILURE","SwapFormStore","resetTradeComposition","inputToken","outputToken","loadDefaultInputToken","loadDefaultOutputToken","localInputTokenAddr","localStorage","getItem","setSelectedInputTokenMetaData","localOutputTokenAddr","setSelectedOutputTokenMetaData","daiAddr","getDaiAddress","output","inputs","method","preview","EXACT_IN","outputAmount","totalOutput","EXACT_OUT","inputAmount","totalInput","outputs","expectedSlippage","validSwap","swapMethod","swapObjection","activeErrorMessage","VALID","slippageCell","extraSlippageAllowanceErrorStatus","proxyStore","previewBatchSwapExactIn","setSwapObjection","NONE","setErrorMessage","setOutputFromPreview","clearErrorMessage","userBalance","findSwapObjection","setTradeCompositionEAI","setValidSwap","previewBatchSwapExactOut","normalizedInput","setTradeCompositionEAO","inputStatus","EMPTY","updateInputsFromObject","setInputAmount","extraSlippageAllowance","valid","tradeCompositionOpen","exchangeRateInput","slippageSelectorOpen","assetModalState","showLoader","switchSwapMethod","oldOutputToken","oldInputToken","setExchangeRateInput","setOutputAmount","assetSelectFilter","tokenAmountIn","sorSwapsFormatted","effectivePrice","setTradeComposition","tokenAmountOut","swaps","inputValue","totalValue","inputPriceValue","outputPriceValue","noPools","tradeCompositionData","others","isOthers","percentage","tempChartSwaps","sorMultiSwap","sequence","swap","firstPoolAddress","pool","secondPoolAddress","swapAmount","div","dp","swapFirst","swapSecond","swapValue","totalPercentage","amount","validateSwapValue","refreshExactAmountInPreview","refreshInvalidInputAmount","refreshExactAmountOutPreview","refreshInvalidOutputAmount","refreshSwapFormPreviewEAI","refreshSwapFormPreviewEAO","getNumberInputValidationStatus","normalizedBalance","gt","INSUFFICIENT_BALANCE","substr","ValidationRules","isFloat","NOT_FLOAT","parseFloat","ZERO","isPositive","NEGATIVE","limitDigits","some","test","MAX_DIGITS_EXCEEDED","outputLimit","inputLimit","limitPrice","open","inputTokenAddress","outputTokenAddress","assetOptionsStore","filteredWhitelistedTokens","getFilteredTokenMetadata","userAllowance","assetOptions","tokenAssetData","addToken","sorStore","setItem","fetchAndSetTokenPairs","fetchPathData","BONE","idiv","calcSpotPrice","tokenBalanceIn","tokenWeightIn","tokenBalanceOut","tokenWeightOut","swapFee","numer","bdiv","denom","bmul","bsubSign","res","b","plus","gte","minus","bool","calcPrice","amountIn","amountOut","price","calcExpectedSlippage","spotPrice","spotPercentage","calcTotalSpotValue","allPools","i","spotPrices","j","balanceIn","weightIn","balanceOut","weightOut","calcMinAmountOut","spotValue","slippagePercent","integerValue","results","calcMaxAmountIn","emptyExactAmountInPreview","spotOutput","emptyExactAmountOutPreview","spotInput","ErrorIds","ErrorCodes","ProxyStore","tokenIn","tokenOut","inputDecimals","setPreviewPending","onChainPools","pools","onChainPoolsPromise","tokenInToFind","getWethAddress","tokenOutToFind","findBestSwapsMulti","costOutputToken","sorSwaps","formatSorSwaps","calcEffectivePrice","outputDecimals","costInputToken","totalInputSpot","isNaN","previewPending","decimalsIn","minAmountOut","decimalsOut","limitReturnAmount","maxPrice","maxAmountIn","BlockchainFetchStore","accountSwitchOverride","getBlockNumber","lastCheckedBlock","setCurrentBlockNumber","updateSwapPreviewForActiveAccount","fetchOnChainTokenDecimals","forceFetch","DropdownStore","walletDropdownVisible","visible","ERROR_MESSAGES","ErrorStore","activeErrors","NO_ERROR","appConfig","colors","key","variables","Array","returnObj","styleKey","style","getStyles","createMuiTheme","palette","primary","chainName","AsyncStatus","contracts","bFactory","proxy","weth","multicall","assets","registry","registryKovan","untrusted","getAssets","ContractMetadataStore","loadWhitelistedTokenMetadata","token","isSupported","existingTokens","indexOf","valueString","includes","tokenUrl","t","AppSettingsStore","darkMode","CostCalculator","gasPerTrade","outTokenEthPrice","costPerTrade","sorTokenPairs","filterAllPools","allTokensSet","getTokenPairsMultiHop","allTokenPairs","tokenPairs","Set","sanitizedWeth","sanitizedToken","has","add","SorStore","costCalculator","processedPools","processedPathsIn","processedPathsOut","epsOfInterestIn","epsOfInterestOut","getPathData","Pools","InputToken","OutputToken","loadPathData","pathData","processPaths","processEpsOfInterestMultiHop","allPoolsNonZeroBalances","filterPoolsWithTokensDirect","directPools","filterPoolsWithTokensMultihop","mostLiquidPoolsFirstHop","mostLiquidPoolsSecondHop","hopTokens","parsePoolData","swapType","maxPools","returnTokenCostPerPool","processedPaths","epsOfInterest","smartOrderRouterMultiHopEpsOfInterest","JSON","parse","stringify","totalReturn","getCostOutputToken","TokenAddr","TokenDecimals","GasPriceWei","SwapGasCost","Provider","cost","REACT_APP_MAX_POOLS","poolsList","outPutTokenDecimals","REACT_APP_GAS_PRICE","REACT_APP_SWAP_COST","inputTokenDecimals","getActiveInputValue","refreshSwapFormPreview","formattedSorSwaps","swapDebug","seqDebug","findPoolTokenInfo","multiSwap","tokenInParam","tokenOutParam","TokenPairsFetch","status","request","payload","getAllPublicSwapPoolsBackup","poolData","p","publicSwap","finalized","getAllPublicSwapPools","fetch","headers","Accept","body","query","json","PoolStore","poolId","obj","tI","tO","denormWeight","totalWeight","loadOnChainPools","loadOnChain","err","getAllPoolDataOnChain","onChainPoolsFresh","fetchTokenPairs","setTokenPairs","getTokenPairsLastFetched","tokenAddressToFind","STALE","verifyChainId","pairs","fromToken","toToken","areTokenPairsLoaded","AssetOptions","isTradable","RootStore","dropdownStore","appSettingsStore","errorStore","AssetOptionsStore","asyncSetup","setDefaultTokenAddresses","storesContext","React","createContext","root","useStores","useContext","useInterval","callback","delay","savedCallback","useRef","useEffect","current","setInterval","clearInterval","MessageWrapper","Spinner","Web3Manager","observer","children","useState","setShowLoader","timeout","setTimeout","clearTimeout","src","Circle","TransactionStatusWrapper","TransactionWrapper","TransactionState","pending","Transaction","href","TransactionListWrapper","Panel","TransactionHeader","TransactionPanel","confirmed","renderTransactions","transactions","getConfirmedTransactions","StyledLink","Lightbox","Wrapper","WALLET_VIEWS","WalletDropdown","walletView","setWalletView","walletDropdownOpen","toggleWalletDropdown","ref","handler","handleClick","event","contains","handleKeyUp","document","addEventListener","removeEventListener","useOnClickOutside","activePrevious","usePrevious","loadWeb3Modal","onClick","loadWalletDropdown","StyledIdenticon","Identicon","innerHTML","appendChild","Jazzicon","parseInt","Container","ButtonBase","ActiveButton","InactiveButton","Button","buttonText","ButtonDisplay","activeButton","WarningIcon","Address","WalletButton","ErrorMessage","span","NetworkIcon","Activity","SpinnerWrapper","Wallet","hasPendingTransactions","alt","getStatusIcon","digits","shortenAddress","Dropup","Dropdown","HeaderFrame","HeaderElement","Title","AppName","Link","Header","Warning","Message","GeneralNotification","PanelHeader","TokenContainer","IconAndNameContainer","TokenIconAddress","TokenIcon","TokenName","TokenBalance","InputWrapper","props","errorBorders","MaxLink","Token","onChange","updateSwapFormData","inputName","inputID","headerText","tokenBalance","truncatedTokenBalance","tokenHasIcon","errorMessage","showMax","modalType","INPUT","OUTPUT","setAssetModalState","onError","IconError","placeholder","BuyToken","TokenPanel","SellToken","SwapIcon","Switch","display","switchInputOutputValues","ErrorTextContainer","ErrorTextContainerPlaceholder","ErrorDisplay","errorText","ErrorTextElement","SlippageInfoContainer","slippageIndicator","SlippageInlineDisplay","errorStatus","InfoPopover","SlippageInfo","lte","toFormat","getSlippageSelectorErrorStatus","setSlippageSelectorOpen","trigger","position","SelectorDropDown","SelectorDropDownCell","ActiveSelectorDropDownCell","Arrow","NumberInput","SlippageSelector","CellGenerator","cellIndex","slippageValue","setSlippageCell","setExtraSlippageAllowance","setSlippageSelectorErrorStatus","updateSlippage","CustomCell","defaultValue","Info","DropDownArrow","OppositeArrows","UpCarretIcon","DownCarretIcon","CompositionDropDown","CompositionTitle","PoolLineContainer","PoolLine","AddressAndBullet","BulletPoint","color","AddressLink","Percentage","PieChartWrapper","TradeComposition","chartData","inputTokenData","outputTokenData","outputValue","multiplier","normalizedOutput","normalizePriceValuesInput","toPrecision","normalizePriceValuesOutput","renderExchangeRate","setTradeCompositionOpen","formatting","borderColor","renderAddress","renderChartRows","borderAlign","borderWidth","weight","pieData","datasets","label","formatPieData","maintainAspectRatio","legend","tooltips","enabled","AssetPanelContainer","AssetPanel","AssetWrapper","NoPool","ErrorLabel","fetchTokenAssetData","manualToken","asset","buckets","tradableWithBalance","tradableWithoutBalance","notTradableWithBalance","notTradableWithoutBalance","hasBalance","sortAssetOptions","tradableTokens","getTokenPairs","getAccountBalances","getAssetOptions","selectAsset","isUntrustedToken","clearTradeComposition","getUntrustedTokens","TradableToken","ModalContent","AssetSelectorHeader","HeaderContent","ExitComponent","InputContainer","AssetSelector","inputRef","focus","setAssetSelectFilter","ButtonState","RowContainer","ColumnContainer","MessageBlock","TradeCompositionPlaceholder","SlippageSelectorPlaceholder","ButtonText","SwapForm","setInputAddress","setOutputAddress","inputAddress","setSelectedInputToken","outputAddress","setSelectedOutputToken","buttonActionHandler","buttonState","NO_WALLET","SWAP","swapHandler","UNLOCK","unlockHandler","tokenToUnlock","approveMax","isPreviewPending","batchSwapExactIn","maxIn","batchSwapExactOut","getButtonText","getButtonActive","inputBalance","isInputValid","isValidInput","isExtraSlippageAmountValid","isValidStatus","isPreviewValid","areInputOutputTokensEqual","inputAmountBN","sufficientAllowance","getButtonState","getActiveError","SWAP_FORM_STORE","BuildVersion","BuildLink","App","PoolSwapView","match","buildId","REACT_APP_COMMIT_REF","Web3ReactManager","className","path","component","to","Boolean","location","hostname","Root","ReactDOM","render","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.f9f651e4.chunk.js","sourcesContent":["function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 309;","module.exports = __webpack_public_path__ + \"static/media/dropdown.7d32d2fa.svg\";","module.exports = __webpack_public_path__ + \"static/media/dropup.0155fd07.svg\";","module.exports = {\"primary\":\"rgb(53, 222, 152)\",\"secondary\":\"rgb(47, 156, 243)\",\"error\":\"rgb(176, 0, 32)\",\"theme1\":\"rgb(38, 166, 154)\",\"margin\":\"20px\",\"radius\":\"5px\",\"darkGrey\":\"rgb(45, 46, 49)\",\"darkGrey35\":\"rgb(33, 33, 33)\",\"grey35\":\"rgb(65, 65, 65)\",\"black\":\"rgb(0, 0, 0)\",\"black35\":\"rgb(16, 16, 16)\",\"black65\":\"rgb(33, 33, 33)\",\"white\":\"rgb(255, 255, 255)\",\"white35\":\"rgb(212, 210, 210)\",\"blue\":\"rgb(63, 81, 181)\",\"lightBlue\":\"rgb(0, 150, 239)\",\"lightGrey\":\"rgb(65, 65, 65)\",\"lighterGrey\":\"rgb(80, 80, 80)\",\"green\":\"rgb(76, 175, 80)\"};","import { BigNumber } from 'bignumber.js';\n\nBigNumber.config({\n    EXPONENTIAL_AT: [-100, 100],\n    ROUNDING_MODE: BigNumber.ROUND_HALF_EVEN,\n    DECIMAL_PLACES: 18,\n});\n\nexport { BigNumber };\n","import styled, { keyframes } from 'styled-components';\nimport { darken } from 'polished';\n\nexport const Button = styled.button.attrs(({ warning, theme }) => ({\n    backgroundColor: warning ? theme.salmonRed : theme.royalBlue,\n}))`\n    padding: 1rem 2rem 1rem 2rem;\n    border-radius: 3rem;\n    cursor: pointer;\n    user-select: none;\n    font-size: 1rem;\n    border: none;\n    outline: none;\n    background-color: ${({ backgroundColor }) => backgroundColor};\n    color: ${({ theme }) => theme.white};\n    width: 100%;\n\n    :hover,\n    :focus {\n        background-color: ${({ backgroundColor }) =>\n            darken(0.05, backgroundColor)};\n    }\n\n    :active {\n        background-color: ${({ backgroundColor }) =>\n            darken(0.1, backgroundColor)};\n    }\n\n    :disabled {\n        background-color: ${({ theme }) => theme.concreteGray};\n        color: ${({ theme }) => theme.silverGray};\n        cursor: auto;\n    }\n`;\n\nexport const Link = styled.a.attrs({\n    target: '_blank',\n    rel: 'noopener noreferrer',\n})`\n    text-decoration: none;\n    cursor: pointer;\n    color: ${({ theme }) => theme.royalBlue};\n\n    :focus {\n        outline: none;\n        text-decoration: underline;\n    }\n\n    :active {\n        text-decoration: none;\n    }\n`;\n\nexport const BorderlessInput = styled.input`\n    color: ${({ theme }) => theme.textColor};\n    font-size: 1rem;\n    outline: none;\n    border: none;\n    flex: 1 1 auto;\n    width: 0;\n    background-color: ${({ theme }) => theme.inputBackground};\n\n    [type='number'] {\n        -moz-appearance: textfield;\n    }\n\n    ::-webkit-outer-spin-button,\n    ::-webkit-inner-spin-button {\n        -webkit-appearance: none;\n    }\n\n    ::placeholder {\n        color: ${({ theme }) => theme.chaliceGray};\n    }\n`;\n\nconst rotate = keyframes`\n  from {\n    transform: rotate(0deg);\n  }\n  to {\n    transform: rotate(360deg);\n  }\n`;\n\nexport const Spinner = styled.img`\n    animation: 2s ${rotate} linear infinite;\n    width: 16px;\n    height: 16px;\n`;\n","import React, { useEffect } from 'react';\nimport {\n    createGlobalStyle,\n    css,\n    ThemeProvider as StyledComponentsThemeProvider,\n} from 'styled-components';\nimport { checkSupportedTheme, getQueryParam } from 'utils/helpers';\nimport { useStores } from '../contexts/storesContext';\n\nexport * from './components';\n\nexport const SUPPORTED_THEMES = {\n    DARK: 'DARK',\n    LIGHT: 'LIGHT',\n};\n\nconst MEDIA_WIDTHS = {\n    upToSmall: 600,\n    upToMedium: 960,\n    upToLarge: 1280,\n};\n\nconst mediaWidthTemplates = Object.keys(MEDIA_WIDTHS).reduce(\n    (accumulator, size) => {\n        accumulator[size] = (...args) => css`\n            @media (max-width: ${MEDIA_WIDTHS[size]}px) {\n                ${css(...args)}\n            }\n        `;\n        return accumulator;\n    },\n    {}\n);\n\nconst white = '#FFFFFF';\nconst black = '#000000';\n\nexport default function ThemeProvider({ children }) {\n    const {\n        root: { appSettingsStore },\n    } = useStores();\n\n    const darkMode = appSettingsStore.darkMode;\n\n    const themeURL = checkSupportedTheme(\n        getQueryParam(window.location, 'theme')\n    );\n    const themeToRender = themeURL\n        ? themeURL.toUpperCase() === SUPPORTED_THEMES.DARK\n            ? true\n            : themeURL.toUpperCase() === SUPPORTED_THEMES.LIGHT\n            ? false\n            : darkMode\n        : darkMode;\n\n    useEffect(() => {\n        appSettingsStore.setDarkMode(themeToRender);\n    }, [appSettingsStore, themeToRender]);\n    return (\n        <StyledComponentsThemeProvider theme={theme(themeToRender)}>\n            {children}\n        </StyledComponentsThemeProvider>\n    );\n}\n\nconst theme = darkMode => ({\n    white,\n    black,\n    textColor: darkMode ? white : '#010101',\n    greyText: darkMode ? white : '#6C7284',\n\n    // for setting css on <html>\n    backgroundColor: darkMode ? '#333639' : white,\n\n    modalBackground: darkMode ? 'rgba(0,0,0,0.6)' : 'rgba(0,0,0,0.5)',\n    inputBackground: darkMode ? '#202124' : white,\n    placeholderGray: darkMode ? '#5F5F5F' : '#E1E1E1',\n    shadowColor: darkMode ? '#000' : '#2F80ED',\n\n    // grays\n    concreteGray: darkMode ? '#292C2F' : '#FAFAFA',\n    mercuryGray: darkMode ? '#333333' : '#E1E1E1',\n    silverGray: darkMode ? '#737373' : '#C4C4C4',\n    chaliceGray: darkMode ? '#7B7B7B' : '#AEAEAE',\n    doveGray: darkMode ? '#C4C4C4' : '#737373',\n    mineshaftGray: darkMode ? '#E1E1E1' : '#2B2B2B',\n    activeGray: darkMode ? '#292C2F' : '#F7F8FA',\n    buttonOutlineGrey: darkMode ? '#FAFAFA' : '#F2F2F2',\n    tokenRowHover: darkMode ? '#404040' : '#F2F2F2',\n\n    //blacks\n    charcoalBlack: darkMode ? '#F2F2F2' : '#404040',\n    // blues\n    zumthorBlue: darkMode ? '#212529' : '#EBF4FF',\n    // TODO refactor; malibuBlue changed as quick hack to a different color JK 013120\n    malibuBlue: darkMode ? '#E67AEF' : '#4C5480',\n    // TODO refactor; royalBlue changed as quick hack to a different color JK 013120\n    royalBlue: darkMode ? '#DC6BE5' : '#fafafa',\n    loadingBlue: darkMode ? '#e4f0ff' : '#e4f0ff',\n\n    // purples\n    wisteriaPurple: '#DC6BE5',\n    // reds\n    salmonRed: '#FF6871',\n    // orange\n    pizazzOrange: '#FF8F05',\n    // yellows\n    warningYellow: '#FFE270',\n    // pink\n    bodyText: '#90a4ae',\n    //green\n    connectedGreen: '#27AE60',\n\n    //branded\n    metaMaskOrange: '#E8831D',\n\n    //specific\n    textHover: darkMode ? theme.bodyText : theme.doveGray,\n\n    // connect button when loggedout\n    buttonFaded: darkMode ? '#DC6BE5' : '#737373',\n\n    // media queries\n    mediaWidth: mediaWidthTemplates,\n    // css snippets\n    flexColumnNoWrap: css`\n        display: flex;\n        flex-flow: column nowrap;\n    `,\n    flexRowNoWrap: css`\n        display: flex;\n        flex-flow: row nowrap;\n    `,\n});\n\nexport const GlobalStyle = createGlobalStyle`\n  @import url('https://rsms.me/inter/inter.css');\n  html { font-family: 'Inter', sans-serif; }\n  @supports (font-variation-settings: normal) {\n    html { font-family: 'Inter var', sans-serif; }\n  }\n  \n  html,\n  body {\n    margin: 0;\n    padding: 0;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;    \n  }\n\n  body > div {\n    height: 100%;\n    overflow: auto;\n    -webkit-overflow-scrolling: touch;\n}\n\n  html {\n    font-size: 16px;\n    font-variant: none;\n    color: ${({ theme }) => theme.textColor};\n    background-color: ${({ theme }) => theme.backgroundColor};\n    -webkit-font-smoothing: antialiased;\n    -moz-osx-font-smoothing: grayscale;\n    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n  }\n`;\n","// Libraries\nimport React from 'react';\nimport jazzicon from 'jazzicon';\nimport { ethers, utils } from 'ethers';\nimport { BigNumber } from 'utils/bignumber';\nimport { SUPPORTED_THEMES } from '../theme';\n\n// Utils\nexport const MAX_GAS = utils.bigNumberify('0xffffffff');\nexport const MAX_UINT = utils.bigNumberify(ethers.constants.MaxUint256);\n\nexport function toChecksum(address) {\n    return utils.getAddress(address);\n}\n\nexport const formatDate = timestamp => {\n    const date = new Date(timestamp * 1000);\n    return `${date.toDateString()} ${addZero(date.getHours())}:${addZero(\n        date.getMinutes()\n    )}:${addZero(date.getSeconds())}`;\n};\n\nexport const addZero = value => {\n    return value > 9 ? value : `0${value}`;\n};\n\nexport function bnum(\n    val: string | number | utils.BigNumber | BigNumber\n): BigNumber {\n    return new BigNumber(val.toString());\n}\n\nexport function scale(input: BigNumber, decimalPlaces: number): BigNumber {\n    const scalePow = new BigNumber(decimalPlaces.toString());\n    const scaleMul = new BigNumber(10).pow(scalePow);\n    return input.times(scaleMul);\n}\n\nexport function fromWei(val: string | utils.BigNumber | BigNumber): string {\n    return utils.formatEther(val.toString());\n}\n\nexport function toWei(val: string | utils.BigNumber | BigNumber): BigNumber {\n    return scale(bnum(val.toString()), 18).integerValue();\n}\n\nexport function setPropertyToMaxUintIfEmpty(value?): string {\n    if (!value || value === 0 || value === '') {\n        value = MAX_UINT.toString();\n    }\n    return value;\n}\n\nexport function setPropertyToZeroIfEmpty(value?): string {\n    if (!value || value === '') {\n        value = '0';\n    }\n    return value;\n}\n\nexport function toAddressStub(address) {\n    const start = address.slice(0, 5);\n    const end = address.slice(-3);\n\n    return `${start}...${end}`;\n}\n\nexport function isEmpty(str: string): boolean {\n    return !str || 0 === str.length;\n}\n\nexport function roundValue(value, decimals = 4): string {\n    const decimalPoint = value.indexOf('.');\n    if (decimalPoint === -1) {\n        return value;\n    }\n    return value.slice(0, decimalPoint + decimals + 1);\n}\n\nexport function str(value: any): string {\n    return value.toString();\n}\n\nexport function shortenAddress(address, digits = 4) {\n    if (!isAddress(address)) {\n        throw Error(`Invalid 'address' parameter '${address}'.`);\n    }\n    return `${address.substring(0, digits + 2)}...${address.substring(\n        42 - digits\n    )}`;\n}\n\nexport function shortenTransactionHash(hash, digits = 4) {\n    return `${hash.substring(0, digits + 2)}...${hash.substring(66 - digits)}`;\n}\n\nexport function isAddress(value) {\n    try {\n        return ethers.utils.getAddress(value.toLowerCase());\n    } catch {\n        return false;\n    }\n}\n\nexport function fromFeeToPercentage(value) {\n    const etherValue = bnum(fromWei(value));\n    const percentageValue = etherValue.times(100);\n    return percentageValue;\n}\n\nexport function formatPctString(value: BigNumber): string {\n    if (value.lte(0.01) && value.gt(0)) {\n        return '<0.01%';\n    }\n    return `${value.toFormat(2, BigNumber.ROUND_HALF_EVEN)}%`;\n}\n\nconst ETHERSCAN_PREFIXES = {\n    1: '',\n    3: 'ropsten.',\n    4: 'rinkeby.',\n    5: 'goerli.',\n    42: 'kovan.',\n};\n\nexport function getEtherscanLink(networkId, data, type) {\n    const prefix = `https://${ETHERSCAN_PREFIXES[networkId] ||\n        ETHERSCAN_PREFIXES[1]}etherscan.io`;\n\n    switch (type) {\n        case 'transaction': {\n            return `${prefix}/tx/${data}`;\n        }\n        case 'address':\n        default: {\n            return `${prefix}/address/${data}`;\n        }\n    }\n}\n\nexport function getQueryParam(windowLocation, name) {\n    var q = windowLocation.search.match(\n        new RegExp('[?&]' + name + '=([^&#?]*)')\n    );\n    return q && q[1];\n}\n\nexport function checkSupportedTheme(themeName) {\n    if (themeName && themeName.toUpperCase() in SUPPORTED_THEMES) {\n        return themeName.toUpperCase();\n    }\n    return null;\n}\n\nexport const copyToClipboard = e => {\n    const value = e.target.title.replace(',', '');\n    var aux = document.createElement('input');\n    aux.setAttribute('value', value);\n    document.body.appendChild(aux);\n    aux.select();\n    document.execCommand('copy');\n    document.body.removeChild(aux);\n    alert(`Value: \"${value}\" copied to clipboard`);\n};\n\nexport const etherscanUrl = network => {\n    return `https://${network !== 'main' ? `${network}.` : ''}etherscan.io`;\n};\n\nexport const etherscanAddress = (network, text, address) => {\n    return (\n        <a\n            className=\"address\"\n            href={`${etherscanUrl(network)}/address/${address}`}\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n        >\n            {text}\n        </a>\n    );\n};\n\nexport const etherscanTx = (network, text, tx) => {\n    return (\n        <a\n            href={`${etherscanUrl(network)}/tx/${tx}`}\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n        >\n            {text}\n        </a>\n    );\n};\n\nexport const etherscanToken = (network, text, token, holder = false) => {\n    return (\n        <a\n            href={`${etherscanUrl(network)}/token/${token}${\n                holder ? `?a=${holder}` : ''\n            }`}\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n        >\n            {text}\n        </a>\n    );\n};\n\nexport const generateIcon = address => {\n    return jazzicon(28, address.substr(0, 10));\n};\n\nexport const normalizePriceValuesInput = (\n    inputValue: BigNumber,\n    inputDecimals: number,\n    outputValue: BigNumber,\n    outputDecimals: number\n): {\n    normalizedInput: BigNumber;\n    normalizedOutput: BigNumber;\n} => {\n    const multiplier = scale(bnum(1), inputDecimals).div(inputValue);\n    return {\n        normalizedInput: bnum(1),\n        normalizedOutput: scale(outputValue.times(multiplier), -outputDecimals),\n    };\n};\n\nexport const normalizePriceValuesOutput = (\n    inputValue: BigNumber,\n    inputDecimals: number,\n    outputValue: BigNumber,\n    outputDecimals: number\n): {\n    normalizedInput: BigNumber;\n    normalizedOutput: BigNumber;\n} => {\n    const multiplier = scale(bnum(1), outputDecimals).div(outputValue);\n    return {\n        normalizedInput: bnum(1),\n        normalizedOutput: scale(inputValue.times(multiplier), -inputDecimals),\n    };\n};\n\nexport const formatBalanceTruncated = (\n    balance: BigNumber,\n    decimals: number,\n    precision: number,\n    truncateAt: number\n): string => {\n    const result = formatBalance(balance, decimals, precision);\n    if (result.length > truncateAt) {\n        return result.substring(0, 20) + '...';\n    } else {\n        return result;\n    }\n};\n\nexport const formatBalance = (\n    balance: BigNumber,\n    decimals: number,\n    precision: number\n): string => {\n    if (balance.eq(0)) {\n        return bnum(0).toFixed(2);\n    }\n\n    const result = scale(balance, -decimals)\n        .decimalPlaces(precision, BigNumber.ROUND_DOWN)\n        .toString();\n\n    return padToDecimalPlaces(result, 2);\n};\n\nexport const padToDecimalPlaces = (\n    value: string,\n    minDecimals: number\n): string => {\n    const split = value.split('.');\n\n    if (!split[1]) {\n        return value + '.00';\n    } else if (split[1].length > 1) {\n        return value;\n    } else {\n        return value + '0';\n    }\n};\n\nexport const getGasPriceFromETHGasStation = () => {\n    return new Promise((resolve, reject) => {\n        const timeout = setTimeout(() => {\n            reject('Request timed out!');\n        }, 3000);\n\n        fetch('https://ethgasstation.info/json/ethgasAPI.json').then(\n            stream => {\n                stream.json().then(price => {\n                    clearTimeout(timeout);\n                    resolve(price);\n                });\n            },\n            e => {\n                clearTimeout(timeout);\n                reject(e);\n            }\n        );\n    });\n};\n\n// TODO: Issue between new BigNumber() and BigNumber() cast in javascript SOR\n// export const formatPoolData = (pools: Pool[]): Pool[] => {\n//     const result: Pool[] = [];\n//     pools.forEach(pool => {\n//         result.push({\n//             id: pool.id,\n//             balanceIn: new BigNumber(fromWei(pool.balanceIn)),\n//             balanceOut: new BigNumber(fromWei(pool.balanceOut)),\n//             weightIn: new BigNumber(fromWei(pool.weightIn)),\n//             weightOut: new BigNumber(fromWei(pool.weightOut)),\n//             swapFee: new BigNumber(fromWei(pool.swapFee)),\n//         });\n//     });\n//     return result;\n// };\n","import * as ethers from 'ethers';\n\nclass UncheckedJsonRpcSigner extends ethers.Signer {\n    signer: any;\n\n    constructor(signer) {\n        super();\n        ethers.utils.defineReadOnly(this, 'signer', signer);\n        ethers.utils.defineReadOnly(this, 'provider', signer.provider);\n    }\n\n    getAddress() {\n        return this.signer.getAddress();\n    }\n\n    sendTransaction(transaction) {\n        return this.signer.sendUncheckedTransaction(transaction).then(hash => {\n            return {\n                hash: hash,\n                nonce: null,\n                gasLimit: null,\n                gasPrice: null,\n                data: null,\n                value: null,\n                chainId: null,\n                confirmations: 0,\n                from: null,\n                wait: confirmations => {\n                    return this.signer.provider.waitForTransaction(\n                        hash,\n                        confirmations\n                    );\n                },\n            };\n        });\n    }\n\n    signMessage(message) {\n        return this.signer.signMessage(message);\n    }\n}\n\nexport default UncheckedJsonRpcSigner;\n","import { Contract } from 'ethers';\nimport { TransactionResponse } from 'ethers/providers';\n\ninterface ActionRequest {\n    contract: Contract;\n    action: string;\n    sender: string;\n    data: any[];\n    overrides: any;\n}\n\nexport interface ActionResponse {\n    contract: Contract;\n    action: string;\n    sender: string;\n    data: object;\n    txResponse: TransactionResponse | undefined;\n    error: any | undefined;\n}\n\nconst preLog = (params: ActionRequest) => {\n    console.log(`[@action start: ${params.action}]`, {\n        contract: params.contract,\n        action: params.action,\n        sender: params.sender,\n        data: params.data,\n        overrides: params.overrides,\n    });\n};\n\nconst postLog = (result: ActionResponse) => {\n    console.log(`[@action end: ${result.action}]`, {\n        contract: result.contract,\n        action: result.action,\n        sender: result.sender,\n        data: result.data,\n        result: result.txResponse,\n        error: result.error,\n    });\n};\n\nexport const sendAction = async (\n    params: ActionRequest\n): Promise<ActionResponse> => {\n    const { contract, action, sender, data, overrides } = params;\n    preLog(params);\n\n    const actionResponse: ActionResponse = {\n        contract,\n        action,\n        sender,\n        data,\n        txResponse: undefined,\n        error: undefined,\n    };\n\n    try {\n        actionResponse.txResponse = await contract[action](...data, overrides);\n    } catch (e) {\n        actionResponse.error = e;\n    }\n\n    postLog(actionResponse);\n    return actionResponse;\n};\n","interface Web3Window extends Window {\n    readonly web3: any;\n    readonly ethereum: any;\n}\n\nconst web3Window = window as Web3Window;\nexport { web3Window };\n","import Web3Modal from 'web3modal';\nimport WalletConnectProvider from '@walletconnect/web3-provider';\nimport Portis from '@portis/web3';\n\nconst providerOptions = {\n    walletconnect: {\n        package: WalletConnectProvider,\n        options: {\n            infuraId: process.env.REACT_APP_INFURA_ID,\n        },\n    },\n    portis: {\n        package: Portis,\n        options: {\n            id: '3f1c3cfc-7dd5-4e8a-aa03-71ff7396d9fe',\n        },\n    },\n};\n\nexport const web3Modal = new Web3Modal({\n    providerOptions: providerOptions,\n    theme: {\n        background: '#282932',\n        main: '#282932',\n        secondary: '#90a4ae',\n        border: '#41476b',\n        hover: '#21222c',\n    },\n});\n\nexport const supportedChainId = Number(\n    process.env.REACT_APP_SUPPORTED_NETWORK_ID\n);\n\nexport const getSupportedChainId = () => {\n    return supportedChainId;\n};\n\nexport const getSupportedChainName = () => {\n    return chainNameById[supportedChainId];\n};\n\nexport const chainNameById = {\n    '1': 'mainnet',\n    '3': 'ropsten',\n    '42': 'kovan',\n};\n\nexport const isChainIdSupported = (chainId: number): boolean => {\n    return supportedChainId === chainId;\n};\n\nconst RPC_URLS: { [chainId: number]: string } = {\n    1: process.env.REACT_APP_RPC_URL_1 as string,\n    3: process.env.REACT_APP_RPC_URL_3 as string,\n    42: process.env.REACT_APP_RPC_URL_42 as string,\n};\n\nexport const SUBGRAPH_URLS: { [chainId: number]: string } = {\n    1: process.env.REACT_APP_SUBGRAPH_URL_1 as string,\n    3: process.env.REACT_APP_SUBGRAPH_URL_3 as string,\n    42: process.env.REACT_APP_SUBGRAPH_URL_42 as string,\n};\n\nexport const backupUrls = {};\nbackupUrls[supportedChainId] = RPC_URLS[supportedChainId];\n\nexport const SUPPORTED_WALLETS = {\n    INJECTED: {\n        isInjected: true,\n        name: 'Injected',\n        iconName: 'arrow-right.svg',\n        description: 'Injected web3 provider.',\n        href: null,\n        color: '#010101',\n        primary: true,\n    },\n    METAMASK: {\n        isInjected: true,\n        name: 'MetaMask',\n        iconName: 'metamask.png',\n        description: 'Easy-to-use browser extension.',\n        href: null,\n        color: '#E8831D',\n    },\n};\n","import { action, observable, ObservableMap } from 'mobx';\nimport RootStore from 'stores/Root';\nimport { ethers } from 'ethers';\nimport UncheckedJsonRpcSigner from 'provider/UncheckedJsonRpcSigner';\nimport { ActionResponse, sendAction } from './actions/actions';\nimport { web3Window as window } from 'provider/Web3Window';\nimport { backupUrls, supportedChainId, web3Modal } from 'provider/connectors';\n\nexport enum ContractTypes {\n    BPool = 'BPool',\n    BFactory = 'BFactory',\n    TestToken = 'TestToken',\n    ExchangeProxy = 'ExchangeProxy',\n    Multicall = 'Multicall',\n    TestTokenBytes = 'TestTokenBytes',\n}\n\nexport const schema = {\n    BPool: require('../abi/BPool').abi,\n    BFactory: require('../abi/BFactory').abi,\n    TestToken: require('../abi/TestToken').abi,\n    ExchangeProxy: require('../abi/ExchangeProxy').abi,\n    Multicall: require('../abi/Multicall').abi,\n    TestTokenBytes: require('../abi/BTokenBytes32').abi,\n};\n\nexport interface ChainData {\n    currentBlockNumber: number;\n}\n\nenum ERRORS {\n    UntrackedChainId = 'Attempting to access data for untracked chainId',\n    ContextNotFound = 'Specified context name note stored',\n    BlockchainActionNoAccount = 'Attempting to do blockchain transaction with no account',\n    BlockchainActionNoChainId = 'Attempting to do blockchain transaction with no chainId',\n    BlockchainActionNoResponse = 'No error or response received from blockchain action',\n    NoWeb3 = 'Error Loading Web3',\n}\n\ntype ChainDataMap = ObservableMap<number, ChainData>;\n\nexport interface ProviderStatus {\n    activeChainId: number;\n    account: string;\n    library: any;\n    active: boolean;\n    injectedLoaded: boolean;\n    injectedActive: boolean;\n    injectedChainId: number;\n    injectedWeb3: any;\n    backUpLoaded: boolean;\n    backUpWeb3: any;\n    activeProvider: any;\n    error: Error;\n}\n\nexport default class ProviderStore {\n    @observable chainData: ChainData;\n    @observable providerStatus: ProviderStatus;\n    web3Modal: any;\n    rootStore: RootStore;\n\n    constructor(rootStore) {\n        this.rootStore = rootStore;\n        this.chainData = { currentBlockNumber: -1 } as ChainData;\n        this.web3Modal = web3Modal;\n        this.providerStatus = {} as ProviderStatus;\n        this.providerStatus.active = false;\n        this.providerStatus.injectedLoaded = false;\n        this.providerStatus.injectedActive = false;\n        this.providerStatus.backUpLoaded = false;\n        this.providerStatus.activeProvider = null;\n\n        this.handleNetworkChanged = this.handleNetworkChanged.bind(this);\n        this.handleClose = this.handleClose.bind(this);\n        this.handleAccountsChanged = this.handleAccountsChanged.bind(this);\n    }\n\n    getCurrentBlockNumber(): number {\n        return this.chainData.currentBlockNumber;\n    }\n\n    async loadWeb3Modal(): Promise<void> {\n        let provider = await this.web3Modal.connect();\n        console.log(`[Provider] Web3Modal`);\n        if (provider) await this.loadWeb3(provider);\n    }\n\n    @action setCurrentBlockNumber(blockNumber): void {\n        this.chainData.currentBlockNumber = blockNumber;\n    }\n\n    @action fetchUserBlockchainData = async (account: string) => {\n        const {\n            transactionStore,\n            tokenStore,\n            contractMetadataStore,\n            swapFormStore,\n        } = this.rootStore;\n\n        console.debug('[Provider] fetchUserBlockchainData', {\n            account,\n        });\n\n        transactionStore.checkPendingTransactions(account);\n        await tokenStore.fetchBalancerTokenData(\n            account,\n            contractMetadataStore.getTrackedTokenAddresses()\n        );\n\n        // Makes sure the Input/Output token data is up to date\n        swapFormStore.updateSelectedTokenMetaData(account);\n    };\n\n    // account is optional\n    getProviderOrSigner(library, account) {\n        console.debug('[getProviderOrSigner', {\n            library,\n            account,\n            signer: library.getSigner(account),\n        });\n\n        return account\n            ? new UncheckedJsonRpcSigner(library.getSigner(account))\n            : library;\n    }\n\n    getContract(\n        type: ContractTypes,\n        address: string,\n        signerAccount?: string\n    ): ethers.Contract {\n        const library = this.providerStatus.library;\n\n        if (signerAccount) {\n            return new ethers.Contract(\n                address,\n                schema[type],\n                this.getProviderOrSigner(\n                    this.providerStatus.library,\n                    signerAccount\n                )\n            );\n        }\n\n        return new ethers.Contract(address, schema[type], library);\n    }\n\n    @action sendTransaction = async (\n        contractType: ContractTypes,\n        contractAddress: string,\n        action: string,\n        params: any[],\n        overrides?: any\n    ): Promise<ActionResponse> => {\n        const { transactionStore } = this.rootStore;\n        const chainId = this.providerStatus.activeChainId;\n        const account = this.providerStatus.account;\n\n        overrides = overrides ? overrides : {};\n\n        if (!account) {\n            throw new Error(ERRORS.BlockchainActionNoAccount);\n        }\n\n        if (!chainId) {\n            throw new Error(ERRORS.BlockchainActionNoChainId);\n        }\n\n        const contract = this.getContract(\n            contractType,\n            contractAddress,\n            account\n        );\n\n        const response = await sendAction({\n            contract,\n            action,\n            sender: account,\n            data: params,\n            overrides,\n        });\n\n        const { error, txResponse } = response;\n\n        if (error) {\n            console.warn('[Send Transaction Error', error);\n        } else if (txResponse) {\n            transactionStore.addTransactionRecord(account, txResponse);\n        } else {\n            throw new Error(ERRORS.BlockchainActionNoResponse);\n        }\n\n        return response;\n    };\n\n    @action async handleNetworkChanged(\n        networkId: string | number\n    ): Promise<void> {\n        console.log(\n            `[Provider] Network change: ${networkId} ${this.providerStatus.active}`\n        );\n        // network change could mean switching from injected to backup or vice-versa\n        if (this.providerStatus.active) {\n            await this.loadWeb3();\n            const { blockchainFetchStore } = this.rootStore;\n            blockchainFetchStore.blockchainFetch(true);\n        }\n    }\n\n    @action async handleClose(): Promise<void> {\n        console.log(`[Provider] HandleClose() ${this.providerStatus.active}`);\n        if (this.providerStatus.active) await this.loadWeb3();\n    }\n\n    @action handleAccountsChanged(accounts: string[]): void {\n        console.log(`[Provider] Accounts changed`);\n        if (accounts.length === 0) {\n            this.handleClose();\n        } else {\n            const { blockchainFetchStore } = this.rootStore;\n            this.providerStatus.account = accounts[0];\n            // Loads pool & balance data for account\n            blockchainFetchStore.blockchainFetch(true);\n        }\n    }\n\n    @action async loadProvider(provider) {\n        try {\n            // remove any old listeners\n            if (\n                this.providerStatus.activeProvider &&\n                this.providerStatus.activeProvider.on\n            ) {\n                console.log(`[Provider] Removing Old Listeners`);\n                this.providerStatus.activeProvider.removeListener(\n                    'chainChanged',\n                    this.handleNetworkChanged\n                );\n                this.providerStatus.activeProvider.removeListener(\n                    'accountsChanged',\n                    this.handleAccountsChanged\n                );\n                this.providerStatus.activeProvider.removeListener(\n                    'close',\n                    this.handleClose\n                );\n                this.providerStatus.activeProvider.removeListener(\n                    'networkChanged',\n                    this.handleNetworkChanged\n                );\n            }\n\n            if (\n                this.providerStatus.library &&\n                this.providerStatus.library.close\n            ) {\n                console.log(`[Provider] Closing Old Library.`);\n                await this.providerStatus.library.close();\n            }\n\n            let web3 = new ethers.providers.Web3Provider(provider);\n\n            if ((provider as any).isMetaMask) {\n                console.log(`[Provider] MetaMask Auto Refresh Off`);\n                (provider as any).autoRefreshOnNetworkChange = false;\n            }\n\n            if (provider.on) {\n                console.log(`[Provider] Subscribing Listeners`);\n                provider.on('chainChanged', this.handleNetworkChanged); // For now assume network/chain ids are same thing as only rare case when they don't match\n                provider.on('accountsChanged', this.handleAccountsChanged);\n                provider.on('close', this.handleClose);\n                provider.on('networkChanged', this.handleNetworkChanged);\n            }\n\n            let network = await web3.getNetwork();\n\n            const accounts = await web3.listAccounts();\n            let account = null;\n            if (accounts.length > 0) account = accounts[0];\n\n            this.providerStatus.injectedLoaded = true;\n            this.providerStatus.injectedChainId = network.chainId;\n            this.providerStatus.account = account;\n            this.providerStatus.injectedWeb3 = web3;\n            this.providerStatus.activeProvider = provider;\n            console.log(`[Provider] Injected provider loaded.`);\n        } catch (err) {\n            console.error(`[Provider] Injected Error`, err);\n            this.providerStatus.injectedLoaded = false;\n            this.providerStatus.injectedChainId = null;\n            this.providerStatus.account = null;\n            this.providerStatus.library = null;\n            this.providerStatus.active = false;\n            this.providerStatus.activeProvider = null;\n        }\n    }\n\n    @action async loadWeb3(provider = null) {\n        /*\n        Handles loading web3 provider.\n        Injected web3 loaded and active if chain Id matches.\n        Backup web3 loaded and active if no injected or injected chain Id not correct.\n        */\n        if (provider === null && window.ethereum) {\n            console.log(`[Provider] Loading Injected Provider`);\n            await this.loadProvider(window.ethereum);\n        } else if (provider) {\n            console.log(`[Provider] Loading Provider`);\n            await this.loadProvider(provider);\n        }\n\n        // If no injected provider or inject provider is wrong chain fall back to Infura\n        if (\n            !this.providerStatus.injectedLoaded ||\n            this.providerStatus.injectedChainId !== supportedChainId\n        ) {\n            console.log(\n                `[Provider] Reverting To Backup Provider.`,\n                this.providerStatus\n            );\n            try {\n                let web3 = new ethers.providers.JsonRpcProvider(\n                    backupUrls[supportedChainId]\n                );\n                let network = await web3.getNetwork();\n                this.providerStatus.injectedActive = false;\n                this.providerStatus.backUpLoaded = true;\n                this.providerStatus.account = null;\n                this.providerStatus.activeChainId = network.chainId;\n                this.providerStatus.backUpWeb3 = web3;\n                this.providerStatus.library = web3;\n                this.providerStatus.activeProvider = 'backup'; //backupUrls[supportedChainId];\n                console.log(`[Provider] BackUp Provider Loaded & Active`);\n            } catch (err) {\n                console.error(`[Provider] loadWeb3 BackUp Error`, err);\n                this.providerStatus.injectedActive = false;\n                this.providerStatus.backUpLoaded = false;\n                this.providerStatus.account = null;\n                this.providerStatus.activeChainId = null;\n                this.providerStatus.backUpWeb3 = null;\n                this.providerStatus.library = null;\n                this.providerStatus.active = false;\n                this.providerStatus.error = new Error(ERRORS.NoWeb3);\n                this.providerStatus.activeProvider = null;\n                return;\n            }\n        } else {\n            console.log(`[Provider] Injected provider active.`);\n            this.providerStatus.library = this.providerStatus.injectedWeb3;\n            this.providerStatus.activeChainId = this.providerStatus.injectedChainId;\n            // Only fetch if not first page load as could be change of provider\n            if (\n                this.providerStatus.account &&\n                this.providerStatus.injectedActive\n            )\n                this.fetchUserBlockchainData(this.providerStatus.account);\n\n            this.providerStatus.injectedActive = true;\n        }\n\n        this.providerStatus.active = true;\n        console.log(`[Provider] Provider Active.`, this.providerStatus);\n    }\n}\n","import { action, observable } from 'mobx';\nimport { providers } from 'ethers';\nimport RootStore from 'stores/Root';\nimport { TransactionResponse } from 'ethers/providers';\n\nexport interface TransactionRecord {\n    hash: string;\n    response: providers.TransactionResponse;\n    blockNumberChecked: number;\n    receipt: providers.TransactionReceipt | undefined;\n}\n\nconst ERRORS = {\n    unknownTxHash: 'Transaction hash is not stored',\n    unknownNetworkId: 'NetworkID specified is not tracked',\n    txHashAlreadyExists: 'Transaction hash already exists for network',\n    txHasNoHash: 'Attempting to add transaction record without hash',\n};\n\nexport enum FetchCode {\n    SUCCESS,\n    FAILURE,\n    STALE,\n}\n\nexport interface TransactionRecordMap {\n    [index: string]: TransactionRecord[];\n}\n\nexport default class TransactionStore {\n    @observable txRecords: TransactionRecordMap;\n    rootStore: RootStore;\n\n    constructor(rootStore) {\n        this.rootStore = rootStore;\n        this.txRecords = {} as TransactionRecordMap;\n    }\n\n    // @dev Transactions are pending if we haven't seen their receipt yet\n    getPendingTransactions(account: string): TransactionRecord[] {\n        if (this.txRecords[account]) {\n            const records = this.txRecords[account];\n            return records.filter(value => {\n                return this.isTxPending(value);\n            });\n        }\n\n        return [] as TransactionRecord[];\n    }\n\n    getConfirmedTransactions(account: string): TransactionRecord[] {\n        if (this.txRecords[account]) {\n            const records = this.txRecords[account];\n            return records.filter(value => {\n                return !this.isTxPending(value);\n            });\n        }\n\n        return [] as TransactionRecord[];\n    }\n\n    hasPendingTransactions(account: string): boolean {\n        let pending = this.getPendingTransactions(account);\n        if (pending.length > 0) return true;\n        return false;\n    }\n\n    @action async checkPendingTransactions(account): Promise<FetchCode> {\n        const { providerStore, poolStore } = this.rootStore;\n        const currentBlock = providerStore.getCurrentBlockNumber();\n\n        const library = providerStore.providerStatus.library;\n        if (this.txRecords[account]) {\n            const records = this.txRecords[account];\n            records.forEach(value => {\n                if (\n                    this.isTxPending(value) &&\n                    this.isStale(value, currentBlock)\n                ) {\n                    library\n                        .getTransactionReceipt(value.hash)\n                        .then(receipt => {\n                            value.blockNumberChecked = currentBlock;\n                            if (receipt) {\n                                value.receipt = receipt;\n                                poolStore.loadPoolsList();\n                            }\n                        })\n                        .catch(() => {\n                            value.blockNumberChecked = currentBlock;\n                        });\n                }\n            });\n        }\n\n        return FetchCode.SUCCESS;\n    }\n\n    // @dev Add transaction record. It's in a pending state until mined.\n    @action addTransactionRecord(\n        account: string,\n        txResponse: TransactionResponse\n    ) {\n        const record: TransactionRecord = {\n            hash: txResponse.hash,\n            response: txResponse,\n            blockNumberChecked: 0,\n            receipt: undefined,\n        };\n\n        const txHash = txResponse.hash;\n\n        if (!txHash) {\n            throw new Error(\n                'Attempting to add transaction record without hash'\n            );\n        }\n\n        let records = this.txRecords[account];\n\n        if (records) {\n            const duplicate = records.find(value => value.hash === txHash);\n            if (!!duplicate) {\n                throw new Error(ERRORS.txHashAlreadyExists);\n            }\n            this.txRecords[account].push(record);\n        } else {\n            this.txRecords[account] = [] as TransactionRecord[];\n            this.txRecords[account].push(record);\n        }\n    }\n\n    private isTxPending(txRecord: TransactionRecord): boolean {\n        return !txRecord.receipt;\n    }\n\n    private isStale(txRecord: TransactionRecord, currentBlock: number) {\n        return txRecord.blockNumberChecked < currentBlock;\n    }\n}\n","import { action, observable } from 'mobx';\nimport RootStore from 'stores/Root';\nimport { ValidationRules } from 'react-form-validator-core';\nimport {\n    ExactAmountInPreview,\n    ExactAmountOutPreview,\n    SwapPreview,\n} from './Proxy';\nimport { SorMultiSwap } from './Sor';\nimport { BigNumber } from 'utils/bignumber';\nimport {\n    bnum,\n    scale,\n    str,\n    isEmpty,\n    formatBalanceTruncated,\n    toChecksum,\n} from '../utils/helpers';\nimport { TokenMetadata, EtherKey } from './Token';\n\nexport enum SwapMethods {\n    EXACT_IN = 'swapExactIn',\n    EXACT_OUT = 'swapExactOut',\n}\n\nexport enum SwapObjection {\n    NONE = 'NONE',\n    INSUFFICIENT_BALANCE = 'Insufficient Balance',\n}\n\nexport enum InputValidationStatus {\n    VALID = 'Valid',\n    EMPTY = 'Empty',\n    ZERO = 'Zero',\n    NOT_FLOAT = 'Not Float',\n    NEGATIVE = 'Negative',\n    MAX_DIGITS_EXCEEDED = 'Maximum Digits Exceeded',\n}\n\nexport enum ModalType {\n    INPUT = 'Input',\n    OUTPUT = 'Output',\n}\n\nexport interface ChartData {\n    validSwap: boolean;\n    swaps: ChartSwap[];\n    inputPriceValue: BigNumber;\n    outputPriceValue: BigNumber;\n    noPools?: number;\n}\n\nexport interface ChartSwap {\n    isOthers: boolean;\n    firstPoolAddress?: string;\n    secondPoolAddress?: string;\n    percentage: number;\n    noPools?: number;\n}\n\nexport default class SwapFormStore {\n    @observable inputs = {\n        inputAmount: '',\n        outputAmount: '',\n        extraSlippageAllowance: '1.0',\n        extraSlippageAllowanceErrorStatus: InputValidationStatus.VALID,\n        swapMethod: SwapMethods.EXACT_IN,\n        outputLimit: '0',\n        inputLimit: '0',\n        limitPrice: '0',\n        swaps: [],\n    };\n    @observable inputToken: TokenMetadata;\n    @observable outputToken: TokenMetadata;\n    // These are for outputs TO the user\n    @observable outputs = {\n        expectedSlippage: '0',\n        validSwap: false,\n        activeErrorMessage: '',\n        swapObjection: '',\n    };\n    @observable preview: SwapPreview;\n    @observable tradeCompositionData: ChartData;\n    @observable tradeCompositionOpen: boolean;\n    @observable exchangeRateInput: boolean = true;\n    @observable slippageSelectorOpen: boolean;\n    @observable assetModalState = {\n        open: false,\n        input: 'inputAmount',\n    };\n    @observable assetSelectFilter: string = '';\n    @observable slippageCell: number = 3;\n    @observable showLoader: boolean = false;\n    account: string = '';\n    rootStore: RootStore;\n\n    constructor(rootStore) {\n        this.rootStore = rootStore;\n        this.resetTradeComposition();\n        this.inputToken = {\n            address: '',\n            symbol: '',\n            name: '',\n            decimals: 18,\n            hasIcon: false,\n            precision: 4,\n            balanceFormatted: '0.00',\n            balanceBn: bnum(0),\n            allowance: undefined,\n        };\n\n        this.outputToken = {\n            address: '',\n            symbol: '',\n            name: '',\n            decimals: 18,\n            hasIcon: false,\n            precision: 4,\n            balanceFormatted: '0.00',\n            balanceBn: bnum(0),\n            allowance: undefined,\n        };\n    }\n\n    @action setDefaultTokenAddresses(account) {\n        this.loadDefaultInputToken(account);\n        this.loadDefaultOutputToken(account);\n    }\n\n    @action loadDefaultInputToken(account) {\n        const localInputTokenAddr = localStorage.getItem('inputToken');\n\n        if (localInputTokenAddr && account)\n            this.setSelectedInputTokenMetaData(localInputTokenAddr, account);\n        else this.setSelectedInputTokenMetaData('ether', account);\n    }\n\n    @action loadDefaultOutputToken(account) {\n        const localOutputTokenAddr = localStorage.getItem('outputToken');\n\n        if (localOutputTokenAddr && account)\n            this.setSelectedOutputTokenMetaData(localOutputTokenAddr, account);\n        else {\n            const { contractMetadataStore } = this.rootStore;\n            const daiAddr = contractMetadataStore.getDaiAddress();\n            this.setSelectedOutputTokenMetaData(daiAddr, account);\n        }\n    }\n\n    @action updateInputsFromObject(output) {\n        this.inputs = {\n            ...this.inputs,\n            ...output,\n        };\n    }\n\n    @action setOutputFromPreview(\n        method: SwapMethods,\n        preview: ExactAmountInPreview | ExactAmountOutPreview,\n        decimals: number\n    ) {\n        if (method === SwapMethods.EXACT_IN) {\n            preview = preview as ExactAmountInPreview;\n            this.inputs.outputAmount = scale(\n                preview.totalOutput,\n                -decimals\n            ).toString();\n        } else if (method === SwapMethods.EXACT_OUT) {\n            preview = preview as ExactAmountOutPreview;\n            this.inputs.inputAmount = scale(\n                preview.totalInput,\n                -decimals\n            ).toString();\n        } else {\n            throw new Error('Invalid swap method specified');\n        }\n\n        this.preview = preview;\n\n        this.outputs = {\n            ...this.outputs,\n            expectedSlippage: str(preview.expectedSlippage),\n            validSwap: true,\n        };\n    }\n\n    @action switchSwapMethod() {\n        const { swapMethod } = this.inputs;\n        if (swapMethod === SwapMethods.EXACT_IN) {\n            this.inputs.swapMethod = SwapMethods.EXACT_OUT;\n        } else {\n            this.inputs.swapMethod = SwapMethods.EXACT_IN;\n        }\n    }\n\n    @action setSwapObjection(message: string) {\n        this.outputs.swapObjection = message;\n    }\n\n    @action setErrorMessage(message: string) {\n        this.outputs.activeErrorMessage = message;\n    }\n\n    isValidStatus(value: InputValidationStatus) {\n        return value === InputValidationStatus.VALID;\n    }\n\n    @action setSlippageCell(value: number) {\n        this.slippageCell = value;\n    }\n\n    getSlippageSelectorErrorStatus(): InputValidationStatus {\n        return this.inputs.extraSlippageAllowanceErrorStatus;\n    }\n\n    async refreshExactAmountInPreview() {\n        const { proxyStore, providerStore } = this.rootStore;\n        const account = providerStore.providerStatus.account;\n        const { inputAmount } = this.inputs;\n\n        const preview = await proxyStore.previewBatchSwapExactIn(\n            this.inputToken.address,\n            this.outputToken.address,\n            bnum(inputAmount),\n            this.inputToken.decimals\n        );\n\n        this.setSwapObjection(SwapObjection.NONE);\n\n        if (preview.error) {\n            this.setErrorMessage(preview.error);\n        }\n\n        if (preview.validSwap) {\n            this.setOutputFromPreview(\n                SwapMethods.EXACT_IN,\n                preview,\n                this.outputToken.decimals\n            );\n            this.clearErrorMessage();\n\n            if (account) {\n                const userBalance = scale(\n                    this.inputToken.balanceBn,\n                    -this.inputToken.decimals\n                );\n\n                if (userBalance) {\n                    this.setSwapObjection(\n                        this.findSwapObjection(\n                            bnum(inputAmount),\n                            account,\n                            userBalance\n                        )\n                    );\n                }\n            }\n            this.setTradeCompositionEAI(preview);\n        } else {\n            this.setValidSwap(false);\n            this.resetTradeComposition();\n        }\n    }\n\n    async refreshExactAmountOutPreview() {\n        const { proxyStore, providerStore } = this.rootStore;\n        const account = providerStore.providerStatus.account;\n        const { outputAmount } = this.inputs;\n\n        const preview = await proxyStore.previewBatchSwapExactOut(\n            this.inputToken.address,\n            this.outputToken.address,\n            bnum(outputAmount),\n            this.outputToken.decimals\n        );\n\n        if (preview.error) {\n            this.setErrorMessage(preview.error);\n        }\n\n        if (preview.validSwap) {\n            this.setOutputFromPreview(\n                SwapMethods.EXACT_OUT,\n                preview,\n                this.inputToken.decimals\n            );\n            this.clearErrorMessage();\n\n            if (account) {\n                const userBalance = scale(\n                    this.inputToken.balanceBn,\n                    -this.inputToken.decimals\n                );\n\n                const normalizedInput = scale(\n                    bnum(preview.totalInput),\n                    -this.inputToken.decimals\n                );\n\n                if (userBalance) {\n                    this.setSwapObjection(\n                        this.findSwapObjection(\n                            normalizedInput,\n                            account,\n                            userBalance\n                        )\n                    );\n                }\n            }\n\n            this.setTradeCompositionEAO(preview);\n        } else {\n            this.setValidSwap(false);\n            this.resetTradeComposition();\n        }\n    }\n\n    refreshInvalidInputAmount(value, inputStatus) {\n        console.log('[Invalid Input]', inputStatus, value);\n        if (value === this.inputs.inputAmount) {\n            // Clear error messages on updating to empty input\n            if (inputStatus === InputValidationStatus.EMPTY) {\n                this.updateInputsFromObject({\n                    outputAmount: '',\n                });\n                this.clearErrorMessage();\n                this.resetTradeComposition();\n            } else {\n                this.updateInputsFromObject({\n                    outputAmount: '',\n                });\n                this.setErrorMessage(inputStatus);\n                this.resetTradeComposition();\n            }\n        }\n    }\n\n    refreshInvalidOutputAmount(value, inputStatus) {\n        console.log('[Invalid Input]', inputStatus, value);\n        if (value === this.inputs.outputAmount) {\n            // Don't show error message on empty value\n            if (inputStatus === InputValidationStatus.EMPTY) {\n                this.setInputAmount('');\n\n                this.clearErrorMessage();\n                this.resetTradeComposition();\n            } else {\n                //Show error message on other invalid input status\n                this.setInputAmount('');\n                this.setErrorMessage(inputStatus);\n                this.resetTradeComposition();\n            }\n        }\n    }\n\n    @action setExtraSlippageAllowance(value: string) {\n        this.inputs.extraSlippageAllowance = value;\n    }\n\n    @action setSlippageSelectorErrorStatus(value: InputValidationStatus) {\n        this.inputs.extraSlippageAllowanceErrorStatus = value;\n    }\n\n    @action clearErrorMessage() {\n        this.outputs.activeErrorMessage = '';\n    }\n\n    @action setValidSwap(valid: boolean) {\n        this.outputs.validSwap = valid;\n    }\n\n    @action setOutputAmount(value: string) {\n        this.inputs.outputAmount = value;\n    }\n\n    @action setInputAmount(value: string) {\n        this.inputs.inputAmount = value;\n    }\n\n    @action setTradeCompositionOpen(value) {\n        this.tradeCompositionOpen = value;\n    }\n\n    @action setExchangeRateInput(value) {\n        this.exchangeRateInput = value;\n    }\n\n    @action setSlippageSelectorOpen(value) {\n        this.slippageSelectorOpen = value;\n    }\n\n    @action setAssetModalState(value: { open?: boolean; input?: string }) {\n        this.assetModalState = {\n            ...this.assetModalState,\n            ...value,\n        };\n    }\n\n    getActiveInputValue(): string {\n        const { swapMethod, inputAmount, outputAmount } = this.inputs;\n        let inputValue;\n        if (swapMethod === SwapMethods.EXACT_IN) {\n            inputValue = inputAmount;\n        } else {\n            inputValue = outputAmount;\n        }\n        return inputValue;\n    }\n\n    @action async switchInputOutputValues() {\n        this.showLoader = true;\n        this.switchSwapMethod();\n\n        const oldOutputToken = this.outputToken;\n        const oldInputToken = this.inputToken;\n        this.inputToken = oldOutputToken;\n        this.outputToken = oldInputToken;\n\n        [this.inputs.inputAmount, this.inputs.outputAmount] = [\n            this.inputs.outputAmount,\n            this.inputs.inputAmount,\n        ];\n\n        if (this.exchangeRateInput) {\n            this.setExchangeRateInput(false);\n        } else {\n            this.setExchangeRateInput(true);\n        }\n    }\n\n    @action clearInputs() {\n        this.setInputAmount('');\n        this.setOutputAmount('');\n        this.clearErrorMessage();\n    }\n\n    @action setAssetSelectFilter(value: string) {\n        this.assetSelectFilter = value;\n    }\n\n    /* Assume swaps are in order of biggest to smallest value */\n    @action setTradeCompositionEAI(preview: ExactAmountInPreview) {\n        const {\n            tokenAmountIn,\n            sorSwapsFormatted,\n            totalOutput,\n            effectivePrice,\n            validSwap,\n        } = preview;\n        this.setTradeComposition(\n            SwapMethods.EXACT_IN,\n            sorSwapsFormatted,\n            tokenAmountIn,\n            totalOutput,\n            effectivePrice,\n            validSwap\n        );\n    }\n\n    /* Assume swaps are in order of biggest to smallest value */\n    @action setTradeCompositionEAO(preview: ExactAmountOutPreview) {\n        const {\n            tokenAmountOut,\n            sorSwapsFormatted,\n            totalInput,\n            effectivePrice,\n            validSwap,\n        } = preview;\n        this.setTradeComposition(\n            SwapMethods.EXACT_OUT,\n            sorSwapsFormatted,\n            tokenAmountOut,\n            totalInput,\n            effectivePrice,\n            validSwap\n        );\n    }\n\n    @action private setTradeComposition(\n        method: SwapMethods,\n        swaps: SorMultiSwap[],\n        inputValue: BigNumber,\n        totalValue: BigNumber,\n        effectivePrice: BigNumber,\n        validSwap: boolean\n    ) {\n        let result: ChartData = {\n            validSwap: true,\n            inputPriceValue: bnum(0),\n            outputPriceValue: bnum(0),\n            swaps: [],\n            noPools: 0,\n        };\n\n        if (!validSwap) {\n            result.validSwap = false;\n            this.tradeCompositionData = result;\n        }\n\n        const others: ChartSwap = {\n            isOthers: true,\n            percentage: 0,\n        };\n\n        const tempChartSwaps: ChartSwap[] = [];\n        // Convert all Swaps to ChartSwaps\n        swaps.forEach(sorMultiSwap => {\n            if (sorMultiSwap.sequence.length === 1) {\n                const swap = sorMultiSwap.sequence[0];\n\n                tempChartSwaps.push({\n                    isOthers: false,\n                    firstPoolAddress: swap.pool,\n                    secondPoolAddress: null,\n                    percentage: bnum(swap.swapAmount)\n                        .div(inputValue)\n                        .times(100)\n                        .dp(2, BigNumber.ROUND_HALF_EVEN)\n                        .toNumber(),\n                    noPools: 1,\n                });\n            } else if (sorMultiSwap.sequence.length > 1) {\n                const swapFirst = sorMultiSwap.sequence[0];\n                const swapSecond = sorMultiSwap.sequence[1];\n\n                const swapValue =\n                    method === SwapMethods.EXACT_IN\n                        ? swapFirst.swapAmount\n                        : swapSecond.swapAmount;\n\n                tempChartSwaps.push({\n                    isOthers: false,\n                    firstPoolAddress: swapFirst.pool,\n                    secondPoolAddress: swapSecond.pool,\n                    percentage: bnum(swapValue)\n                        .div(inputValue)\n                        .times(100)\n                        .dp(2, BigNumber.ROUND_HALF_EVEN)\n                        .toNumber(),\n                    noPools: 2,\n                });\n            }\n        });\n\n        let totalPercentage = 0;\n\n        tempChartSwaps.forEach((value, index) => {\n            if (index === 0 || index === 1 || index === 2) {\n                result.swaps.push(value);\n                result.noPools += value.noPools;\n            } else {\n                others.percentage += value.percentage;\n                result.noPools += 1;\n            }\n\n            totalPercentage += value.percentage;\n        });\n\n        if (others.percentage > 0) {\n            result.swaps.push(others);\n        }\n\n        if (method === SwapMethods.EXACT_IN) {\n            result.inputPriceValue = inputValue;\n            result.outputPriceValue = totalValue;\n        }\n\n        if (method === SwapMethods.EXACT_OUT) {\n            result.inputPriceValue = totalValue;\n            result.outputPriceValue = inputValue;\n        }\n\n        if (totalPercentage !== 100) {\n            console.log(totalPercentage);\n            console.error('Total Percentage Unexpected Value');\n        }\n\n        this.tradeCompositionData = result;\n    }\n\n    @action async refreshSwapFormPreviewEAI(amount: string) {\n        this.inputs.swapMethod = SwapMethods.EXACT_IN;\n        this.inputs.inputAmount = amount;\n\n        const inputStatus = this.validateSwapValue(amount);\n\n        if (inputStatus === InputValidationStatus.VALID) {\n            await this.refreshExactAmountInPreview();\n        } else {\n            this.refreshInvalidInputAmount(amount, inputStatus);\n        }\n    }\n\n    @action async refreshSwapFormPreviewEAO(amount: string) {\n        this.inputs.swapMethod = SwapMethods.EXACT_OUT;\n        this.inputs.outputAmount = amount;\n\n        const inputStatus = this.validateSwapValue(amount);\n\n        if (inputStatus === InputValidationStatus.VALID) {\n            await this.refreshExactAmountOutPreview();\n        } else {\n            this.refreshInvalidOutputAmount(amount, inputStatus);\n        }\n    }\n\n    @action async refreshSwapFormPreview(\n        amount: string,\n        swapMethod: SwapMethods\n    ) {\n        if (swapMethod === SwapMethods.EXACT_IN) {\n            this.refreshSwapFormPreviewEAI(amount);\n        } else if (swapMethod === SwapMethods.EXACT_OUT) {\n            this.refreshSwapFormPreviewEAO(amount);\n        } else {\n            throw new Error('Invalid swap method specified');\n        }\n    }\n\n    @action clearTradeComposition() {\n        this.resetTradeComposition();\n    }\n\n    isValidInput(value: string): boolean {\n        return (\n            this.getNumberInputValidationStatus(value) ===\n            InputValidationStatus.VALID\n        );\n    }\n\n    findSwapObjection(\n        value: BigNumber,\n        account: string | undefined,\n        normalizedBalance: BigNumber\n    ): SwapObjection {\n        console.log('swapObjection', {\n            value,\n            account,\n            normalizedBalance,\n        });\n        // Check for insufficient balance if user logged in\n        if (account && value.gt(normalizedBalance)) {\n            return SwapObjection.INSUFFICIENT_BALANCE;\n        }\n\n        return SwapObjection.NONE;\n    }\n\n    validateSwapValue(value: string): InputValidationStatus {\n        return this.getNumberInputValidationStatus(value);\n    }\n\n    getNumberInputValidationStatus(\n        value: string,\n        options?: {\n            limitDigits?: boolean;\n        }\n    ): InputValidationStatus {\n        if (value.substr(0, 1) === '.') {\n            value = '0' + value;\n        }\n\n        if (ValidationRules.isEmpty(value)) {\n            return InputValidationStatus.EMPTY;\n        }\n\n        if (!ValidationRules.isFloat(value)) {\n            return InputValidationStatus.NOT_FLOAT;\n        }\n\n        if (parseFloat(value).toString() === '0') {\n            return InputValidationStatus.ZERO;\n        }\n\n        if (!ValidationRules.isPositive(value)) {\n            return InputValidationStatus.NEGATIVE;\n        }\n\n        if (options && options.limitDigits) {\n            // restrict to 2 decimal places\n            const acceptableValues = [/^$/, /^\\d{1,2}$/, /^\\d{0,2}\\.\\d{0,2}$/];\n            // if its within accepted decimal limit, update the input state\n            if (!acceptableValues.some(a => a.test(value))) {\n                return InputValidationStatus.MAX_DIGITS_EXCEEDED;\n            }\n        }\n\n        return InputValidationStatus.VALID;\n    }\n\n    resetTradeComposition() {\n        this.tradeCompositionData = {\n            validSwap: false,\n            inputPriceValue: bnum(0),\n            outputPriceValue: bnum(0),\n            swaps: [],\n        };\n    }\n\n    @action updateSelectedTokenMetaData(account) {\n        console.log(`[SwapFormStore] updateSelectedTokenMetaData()`);\n        if (\n            this.inputToken.address !== 'unknown' &&\n            !isEmpty(this.inputToken.address)\n        )\n            this.setSelectedInputTokenMetaData(\n                this.inputToken.address,\n                account\n            );\n\n        if (\n            this.outputToken.address !== 'unknown' &&\n            !isEmpty(this.outputToken.address)\n        )\n            this.setSelectedOutputTokenMetaData(\n                this.outputToken.address,\n                account\n            );\n    }\n\n    @action setInputAddress = async (inputTokenAddress: string) => {\n        this.inputToken.address = inputTokenAddress;\n    };\n\n    @action setOutputAddress = async (outputTokenAddress: string) => {\n        this.outputToken.address = outputTokenAddress;\n    };\n\n    // Fetches and sets the input token metaData.\n    // Fetch will try stored whitelisted info and revert to on-chain if not available\n    // Also loads pool info for token\n    @action setSelectedInputTokenMetaData = async (\n        inputTokenAddress: string,\n        account: string\n    ) => {\n        this.inputToken.address = inputTokenAddress;\n        this.inputToken.hasIcon = false;\n\n        const {\n            contractMetadataStore,\n            assetOptionsStore,\n            tokenStore,\n        } = this.rootStore;\n\n        const filteredWhitelistedTokens = contractMetadataStore.getFilteredTokenMetadata(\n            inputTokenAddress\n        );\n\n        if (filteredWhitelistedTokens.length > 0) {\n            this.inputToken.symbol = filteredWhitelistedTokens[0].symbol;\n            this.inputToken.name = filteredWhitelistedTokens[0].name;\n            this.inputToken.decimals = filteredWhitelistedTokens[0].decimals;\n            this.inputToken.precision = filteredWhitelistedTokens[0].precision;\n            this.inputToken.hasIcon = filteredWhitelistedTokens[0].hasIcon;\n\n            let balanceBn;\n            if (inputTokenAddress !== EtherKey)\n                balanceBn = tokenStore.getBalance(\n                    toChecksum(inputTokenAddress),\n                    account\n                );\n            else balanceBn = tokenStore.getBalance(inputTokenAddress, account);\n\n            if (!balanceBn) balanceBn = bnum(0);\n\n            const userBalance = formatBalanceTruncated(\n                balanceBn,\n                filteredWhitelistedTokens[0].decimals,\n                filteredWhitelistedTokens[0].precision,\n                20\n            );\n\n            const proxyAddress = contractMetadataStore.getProxyAddress();\n            const userAllowance = tokenStore.getAllowance(\n                inputTokenAddress,\n                account,\n                proxyAddress\n            );\n            this.inputToken.allowance = userAllowance;\n            this.inputToken.balanceBn = balanceBn;\n            this.inputToken.balanceFormatted = userBalance;\n        } else {\n            const assetOptions = assetOptionsStore.tokenAssetData;\n            if (assetOptions) {\n                this.inputToken.symbol = assetOptions.symbol;\n                this.inputToken.name = assetOptions.name;\n                this.inputToken.hasIcon = assetOptions.hasIcon;\n                this.inputToken.balanceFormatted = assetOptions.userBalance;\n                this.inputToken.balanceBn = assetOptions.balanceBn;\n                this.inputToken.decimals = assetOptions.decimals;\n                this.inputToken.precision = 4;\n                this.inputToken.allowance = assetOptions.allowance;\n            }\n        }\n\n        console.log(`[SwapFormStore] InputToken`, this.inputToken);\n    };\n\n    @action setSelectedInputToken = async (\n        inputTokenAddress: string,\n        account: string\n    ) => {\n        console.log(\n            `[SwapFormStore] setSelectedInputToken: ${account} ${inputTokenAddress}`\n        );\n\n        const { contractMetadataStore } = this.rootStore;\n\n        try {\n            await contractMetadataStore.addToken(inputTokenAddress, account);\n\n            if (\n                inputTokenAddress === EtherKey &&\n                this.outputToken.address === EtherKey\n            ) {\n                this.setErrorMessage('Please Select Alternative Pair');\n                this.setValidSwap(false);\n                this.resetTradeComposition();\n                return;\n            }\n\n            const { poolStore, sorStore } = this.rootStore;\n\n            this.inputToken.address = inputTokenAddress;\n            localStorage.setItem('inputToken', inputTokenAddress);\n            this.account = account;\n            if (!account) this.updateSelectedTokenMetaData(account);\n\n            console.log(\n                `[SwapFormStore] fetching Token Pairs: ${inputTokenAddress}`\n            );\n            // Uses SOR & AllPools to retrieve all pairs for address, used for Asset Picker\n            poolStore.fetchAndSetTokenPairs(inputTokenAddress);\n            // This uses SOR to get paths between in/out tokens. Quite intensive so loaded ASAP to be ready.\n            // Required for when asset picker selects new tokens\n            sorStore.fetchPathData(inputTokenAddress, this.outputToken.address);\n        } catch (err) {\n            this.inputToken = {\n                address: inputTokenAddress,\n                symbol: 'unknown',\n                name: 'unknown',\n                decimals: 18,\n                hasIcon: false,\n                precision: 4,\n                balanceFormatted: '0.00',\n                balanceBn: bnum(0),\n                allowance: undefined,\n            };\n            this.setErrorMessage(err.message);\n        }\n    };\n\n    // Fetches and sets the input token metaData.\n    // Fetch will try stored whitelisted info and revert to on-chain if not available\n    // Also loads pool info for token\n    @action setSelectedOutputTokenMetaData = async (\n        outputTokenAddress: string,\n        account: string\n    ) => {\n        this.outputToken.address = outputTokenAddress;\n        this.outputToken.hasIcon = false;\n\n        const {\n            contractMetadataStore,\n            assetOptionsStore,\n            tokenStore,\n        } = this.rootStore;\n\n        const filteredWhitelistedTokens = contractMetadataStore.getFilteredTokenMetadata(\n            outputTokenAddress\n        );\n        if (filteredWhitelistedTokens.length > 0) {\n            this.outputToken.symbol = filteredWhitelistedTokens[0].symbol;\n            this.outputToken.name = filteredWhitelistedTokens[0].name;\n            this.outputToken.decimals = filteredWhitelistedTokens[0].decimals;\n            this.outputToken.precision = filteredWhitelistedTokens[0].precision;\n            this.outputToken.hasIcon = filteredWhitelistedTokens[0].hasIcon;\n\n            let balanceBn;\n\n            if (outputTokenAddress !== EtherKey)\n                balanceBn = tokenStore.getBalance(\n                    toChecksum(outputTokenAddress),\n                    account\n                );\n            else balanceBn = tokenStore.getBalance(outputTokenAddress, account);\n\n            if (!balanceBn) balanceBn = bnum(0);\n\n            const userBalance = formatBalanceTruncated(\n                balanceBn,\n                filteredWhitelistedTokens[0].decimals,\n                filteredWhitelistedTokens[0].precision,\n                20\n            );\n            const proxyAddress = contractMetadataStore.getProxyAddress();\n            const userAllowance = tokenStore.getAllowance(\n                outputTokenAddress,\n                account,\n                proxyAddress\n            );\n            this.outputToken.allowance = userAllowance;\n            this.outputToken.balanceBn = balanceBn;\n            this.outputToken.balanceFormatted = userBalance;\n        } else {\n            const assetOptions = assetOptionsStore.tokenAssetData;\n            if (assetOptions) {\n                this.outputToken.symbol = assetOptions.symbol;\n                this.outputToken.name = assetOptions.name;\n                this.outputToken.hasIcon = assetOptions.hasIcon;\n                this.outputToken.balanceFormatted = assetOptions.userBalance;\n                this.outputToken.decimals = assetOptions.decimals;\n                this.outputToken.precision = 4;\n                this.outputToken.allowance = assetOptions.allowance;\n                this.inputToken.balanceBn = assetOptions.balanceBn;\n            }\n        }\n    };\n\n    @action setSelectedOutputToken = async (\n        outputTokenAddress: string,\n        account: string\n    ) => {\n        console.log(\n            `[SwapFormStore] setSelectedOutputToken: ${account} ${outputTokenAddress}`\n        );\n\n        const { contractMetadataStore } = this.rootStore;\n\n        try {\n            await contractMetadataStore.addToken(outputTokenAddress, account);\n\n            if (\n                outputTokenAddress === EtherKey &&\n                this.inputToken.address === EtherKey\n            ) {\n                this.setErrorMessage('Please Select Alternative Pair');\n                this.setValidSwap(false);\n                this.resetTradeComposition();\n                return;\n            }\n\n            const { poolStore, sorStore } = this.rootStore;\n\n            this.outputToken.address = outputTokenAddress;\n            localStorage.setItem('outputToken', outputTokenAddress);\n            this.account = account;\n            console.log(\n                `[SwapFormStore] fetching Token Pairs: ${outputTokenAddress}`\n            );\n            poolStore.fetchAndSetTokenPairs(outputTokenAddress);\n            // Required for when asset picker selects new tokens\n            sorStore.fetchPathData(this.inputToken.address, outputTokenAddress);\n        } catch (err) {\n            this.outputToken = {\n                address: outputTokenAddress,\n                symbol: 'unknown',\n                name: 'unknown',\n                decimals: 18,\n                hasIcon: false,\n                precision: 4,\n                balanceFormatted: '0.00',\n                balanceBn: bnum(0),\n                allowance: undefined,\n            };\n\n            this.setErrorMessage(err.message);\n        }\n    };\n}\n","import { action, observable } from 'mobx';\nimport RootStore from 'stores/Root';\nimport { ContractTypes } from 'stores/Provider';\nimport * as helpers from 'utils/helpers';\nimport { bnum, formatBalanceTruncated } from 'utils/helpers';\nimport { FetchCode } from './Transaction';\nimport { BigNumber } from 'utils/bignumber';\nimport { MAX_UINT } from 'utils/helpers';\nimport { Interface } from 'ethers/utils';\nimport * as ethers from 'ethers';\n\nconst tokenAbi = require('../abi/TestToken').abi;\n\nexport interface ContractMetadata {\n    bFactory: string;\n    proxy: string;\n    weth: string;\n    multicall: string;\n    tokens: TokenMetadata[];\n}\n\nexport interface ContractMetadataMap {\n    [index: number]: ContractMetadata;\n}\n\nexport interface TokenBalance {\n    balance: BigNumber;\n    lastFetched: number;\n}\n\nexport interface UserAllowance {\n    allowance: BigNumber;\n    lastFetched: number;\n}\n\ninterface TokenBalanceMap {\n    [index: string]: {\n        [index: string]: TokenBalance;\n    };\n}\n\nexport interface BigNumberMap {\n    [index: string]: BigNumber;\n}\n\nexport interface TokenMetadata {\n    address: string;\n    symbol: string;\n    name: string;\n    decimals: number;\n    hasIcon: boolean;\n    precision: number;\n    balanceFormatted?: string;\n    balanceBn?: BigNumber;\n    allowance?: BigNumber;\n}\n\ninterface UserAllowanceMap {\n    [index: string]: {\n        [index: string]: {\n            [index: string]: UserAllowance;\n        };\n    };\n}\n\nexport const EtherKey = 'ether';\n\nexport default class TokenStore {\n    @observable balances: TokenBalanceMap;\n    @observable allowances: UserAllowanceMap;\n    @observable contractMetadata: ContractMetadataMap;\n    rootStore: RootStore;\n\n    constructor(rootStore) {\n        this.rootStore = rootStore;\n        this.balances = {} as TokenBalanceMap;\n        this.allowances = {} as UserAllowanceMap;\n        this.contractMetadata = {} as ContractMetadataMap;\n    }\n\n    getAccountBalances(tokens: TokenMetadata[], account: string): BigNumberMap {\n        const userBalances = this.balances;\n        if (!userBalances) {\n            throw new Error(\n                'Attempting to get user balances for untracked chainId'\n            );\n        }\n\n        const result: BigNumberMap = {};\n        tokens.forEach(value => {\n            if (\n                userBalances[value.address] &&\n                userBalances[value.address][account]\n            ) {\n                result[value.address] =\n                    userBalances[value.address][account].balance;\n            }\n        });\n\n        return result;\n    }\n\n    isAllowanceFetched(tokenAddress: string, owner: string, spender: string) {\n        const chainApprovals = this.allowances;\n        return (\n            !!chainApprovals[tokenAddress] &&\n            !!chainApprovals[tokenAddress][owner] &&\n            !!chainApprovals[tokenAddress][owner][spender]\n        );\n    }\n\n    isAllowanceStale(\n        tokenAddress: string,\n        owner: string,\n        spender: string,\n        blockNumber: number\n    ) {\n        const chainApprovals = this.allowances;\n        return (\n            chainApprovals[tokenAddress][owner][spender].lastFetched <\n            blockNumber\n        );\n    }\n\n    setAllowances(\n        tokens: string[],\n        owner: string,\n        spender: string,\n        approvals: BigNumber[],\n        fetchBlock: number\n    ) {\n        const chainApprovals = this.allowances;\n\n        approvals.forEach((approval, index) => {\n            const tokenAddress = tokens[index];\n\n            if (\n                (this.isAllowanceFetched(tokenAddress, owner, spender) &&\n                    this.isAllowanceStale(\n                        tokenAddress,\n                        owner,\n                        spender,\n                        fetchBlock\n                    )) ||\n                !this.isAllowanceFetched(tokenAddress, owner, spender)\n            ) {\n                if (!chainApprovals[tokenAddress]) {\n                    chainApprovals[tokenAddress] = {};\n                }\n\n                if (!chainApprovals[tokenAddress][owner]) {\n                    chainApprovals[tokenAddress][owner] = {};\n                }\n\n                chainApprovals[tokenAddress][owner][spender] = {\n                    allowance: approval,\n                    lastFetched: fetchBlock,\n                };\n            }\n        });\n\n        this.allowances = {\n            ...this.allowances,\n            ...chainApprovals,\n        };\n    }\n\n    isBalanceFetched(tokenAddress: string, account: string) {\n        const chainBalances = this.balances;\n        return (\n            !!chainBalances[tokenAddress] &&\n            !!chainBalances[tokenAddress][account]\n        );\n    }\n\n    isBalanceStale(tokenAddress: string, account: string, blockNumber: number) {\n        const chainBalances = this.balances;\n        return chainBalances[tokenAddress][account].lastFetched < blockNumber;\n    }\n\n    setBalances(\n        tokens: string[],\n        balances: BigNumber[],\n        account: string,\n        fetchBlock: number\n    ) {\n        const fetchedBalances: TokenBalanceMap = {};\n\n        balances.forEach((balance, index) => {\n            const tokenAddress = tokens[index];\n\n            if (\n                (this.isBalanceFetched(tokenAddress, account) &&\n                    this.isBalanceStale(tokenAddress, account, fetchBlock)) ||\n                !this.isBalanceFetched(tokenAddress, account)\n            ) {\n                if (this.balances[tokenAddress]) {\n                    fetchedBalances[tokenAddress] = this.balances[tokenAddress];\n                } else {\n                    fetchedBalances[tokenAddress] = {};\n                }\n\n                fetchedBalances[tokenAddress][account] = {\n                    balance: balance,\n                    lastFetched: fetchBlock,\n                };\n            }\n        });\n\n        this.balances = {\n            ...this.balances,\n            ...fetchedBalances,\n        };\n    }\n\n    getBalance(tokenAddress: string, account: string): BigNumber | undefined {\n        const chainBalances = this.balances;\n        if (chainBalances) {\n            const tokenBalances = chainBalances[tokenAddress];\n            if (tokenBalances) {\n                const balance = tokenBalances[account];\n                if (balance) {\n                    if (balance.balance) {\n                        return balance.balance;\n                    }\n                }\n            }\n        }\n        return undefined;\n    }\n\n    private setDecimals(tokens: string[], decimals: number[]) {\n        const { contractMetadataStore } = this.rootStore;\n\n        let index = 0;\n        tokens.forEach(tokenAddr => {\n            if (tokenAddr === EtherKey) {\n                contractMetadataStore.setTokenDecimals(tokenAddr, 18);\n            } else {\n                contractMetadataStore.setTokenDecimals(\n                    tokenAddr,\n                    decimals[index]\n                );\n                index += 1;\n            }\n        });\n    }\n\n    private getBalanceLastFetched(tokenAddress, account): number | undefined {\n        const chainBalances = this.balances;\n        if (chainBalances) {\n            const tokenBalances = chainBalances[tokenAddress];\n            if (tokenBalances) {\n                const balance = tokenBalances[account];\n                if (balance) {\n                    if (balance.lastFetched) {\n                        return balance.lastFetched;\n                    }\n                }\n            }\n        }\n        return undefined;\n    }\n\n    @action approveMax = async (tokenAddress, spender) => {\n        const { providerStore } = this.rootStore;\n        await providerStore.sendTransaction(\n            ContractTypes.TestToken,\n            tokenAddress,\n            'approve',\n            [spender, helpers.MAX_UINT.toString()]\n        );\n    };\n\n    @action revokeApproval = async (tokenAddress, spender) => {\n        const { providerStore } = this.rootStore;\n        await providerStore.sendTransaction(\n            ContractTypes.TestToken,\n            tokenAddress,\n            'approve',\n            [spender, 0]\n        );\n    };\n\n    @action fetchBalancerTokenData = async (\n        account,\n        tokensToTrack: string[]\n    ): Promise<FetchCode> => {\n        const { providerStore, contractMetadataStore } = this.rootStore;\n        const promises: Promise<any>[] = [];\n        const balanceCalls = [];\n        const allowanceCalls = [];\n        const decimalsCalls = [];\n        const tokenList = [];\n\n        const multiAddress = contractMetadataStore.getMultiAddress();\n        const multi = providerStore.getContract(\n            ContractTypes.Multicall,\n            multiAddress\n        );\n\n        const iface = new Interface(tokenAbi);\n\n        tokensToTrack.forEach(address => {\n            tokenList.push(address);\n            if (address !== EtherKey) {\n                balanceCalls.push([\n                    address,\n                    iface.functions.balanceOf.encode([account]),\n                ]);\n                allowanceCalls.push([\n                    address,\n                    iface.functions.allowance.encode([\n                        account,\n                        contractMetadataStore.getProxyAddress(),\n                    ]),\n                ]);\n\n                decimalsCalls.push([\n                    address,\n                    iface.functions.decimals.encode([]),\n                ]);\n            }\n        });\n\n        promises.push(multi.aggregate(balanceCalls));\n        promises.push(multi.aggregate(allowanceCalls));\n        promises.push(multi.getEthBalance(account));\n        promises.push(multi.aggregate(decimalsCalls));\n\n        try {\n            const [\n                [balBlock, mulBalance],\n                [allBlock, mulAllowance],\n                mulEth,\n                [, mulDecimals],\n            ] = await Promise.all(promises);\n\n            const balances = mulBalance.map(value =>\n                bnum(iface.functions.balanceOf.decode(value))\n            );\n\n            const allowances = mulAllowance.map(value =>\n                bnum(iface.functions.allowance.decode(value))\n            );\n\n            const ethBalance = bnum(mulEth);\n            balances.unshift(ethBalance);\n            allowances.unshift(bnum(helpers.setPropertyToMaxUintIfEmpty()));\n\n            const decimalsList = mulDecimals.map(value =>\n                bnum(iface.functions.decimals.decode(value)).toNumber()\n            );\n\n            this.setAllowances(\n                tokenList,\n                account,\n                contractMetadataStore.getProxyAddress(),\n                allowances,\n                allBlock.toNumber()\n            );\n\n            this.setDecimals(tokenList, decimalsList);\n            this.setBalances(tokenList, balances, account, balBlock.toNumber());\n            console.debug('[All Fetches Success]');\n        } catch (e) {\n            console.error('[Fetch] Balancer Token Data', { error: e });\n            return FetchCode.FAILURE;\n        }\n        return FetchCode.SUCCESS;\n    };\n\n    @action fetchOnChainTokenDecimals = async (\n        tokensToTrack: string[]\n    ): Promise<FetchCode> => {\n        const {\n            providerStore,\n            contractMetadataStore,\n            swapFormStore,\n        } = this.rootStore;\n        const promises: Promise<any>[] = [];\n        const decimalsCalls = [];\n        const tokenList = [];\n\n        console.log('[Token] fetchOnChainTokenDecimals');\n\n        const multiAddress = contractMetadataStore.getMultiAddress();\n        const multi = providerStore.getContract(\n            ContractTypes.Multicall,\n            multiAddress\n        );\n\n        const iface = new Interface(tokenAbi);\n\n        tokensToTrack.forEach(address => {\n            tokenList.push(address);\n            if (address !== EtherKey) {\n                decimalsCalls.push([\n                    address,\n                    iface.functions.decimals.encode([]),\n                ]);\n            }\n        });\n\n        promises.push(multi.aggregate(decimalsCalls));\n\n        try {\n            const [[, mulDecimals]] = await Promise.all(promises);\n\n            const decimalsList = mulDecimals.map(value =>\n                bnum(iface.functions.decimals.decode(value))\n            );\n            this.setDecimals(tokenList, decimalsList);\n            console.log('[Token] fetchOnChainTokenDecimals Finished');\n            swapFormStore.updateSelectedTokenMetaData(undefined);\n        } catch (e) {\n            console.log('[Token] fetchOnChainTokenDecimals Error', {\n                error: e,\n            });\n            return FetchCode.FAILURE;\n        }\n        return FetchCode.SUCCESS;\n    };\n\n    getAllowance = (tokenAddress, account, spender): BigNumber | undefined => {\n        const chainApprovals = this.allowances;\n        if (chainApprovals) {\n            const tokenApprovals = chainApprovals[tokenAddress];\n\n            if (tokenApprovals) {\n                const userApprovals = tokenApprovals[account];\n                if (userApprovals) {\n                    if (userApprovals[spender]) {\n                        return userApprovals[spender].allowance;\n                    }\n                }\n            }\n        }\n        return undefined;\n    };\n\n    async getTokenBalance(\n        tokenAddr,\n        account,\n        tokenContract,\n        decimals,\n        precision\n    ) {\n        // Try whitelisted pre-loaded balances first to avoid another call\n\n        const whiteListedBalanceBn = this.getBalance(tokenAddr, account);\n\n        if (whiteListedBalanceBn) {\n            console.log(\n                `[Token] Using whitelisted Balance: `,\n                whiteListedBalanceBn.toString()\n            );\n\n            const balanceFormatted = formatBalanceTruncated(\n                whiteListedBalanceBn,\n                decimals,\n                precision,\n                20\n            );\n\n            return {\n                balanceBn: whiteListedBalanceBn,\n                balanceFormatted: balanceFormatted,\n            };\n        } else if (account) {\n            console.log(`[Token] Getting On-Chain Balance: ${tokenAddr}`);\n            const balanceWei = await tokenContract.balanceOf(account);\n            const balanceFormatted = formatBalanceTruncated(\n                bnum(balanceWei),\n                decimals,\n                precision,\n                20\n            );\n\n            return {\n                balanceBn: bnum(balanceWei),\n                balanceFormatted: balanceFormatted,\n            };\n        } else {\n            return { balanceBn: bnum(0), balanceFormatted: '0.00' };\n        }\n    }\n\n    fetchOnChainTokenMetadata = async (\n        address: string,\n        account: string\n    ): Promise<TokenMetadata> => {\n        console.log(`[Token] fetchOnChainTokenMetadata: ${address} ${account}`);\n\n        const { providerStore, contractMetadataStore } = this.rootStore;\n\n        let tokenMetadata;\n        const proxyAddress = contractMetadataStore.getProxyAddress();\n\n        if (address === EtherKey) {\n            tokenMetadata = {\n                address: address,\n                symbol: 'ETH',\n                name: 'Ether',\n                decimals: 18,\n                hasIcon: true,\n                precision: 4,\n                balanceBn: bnum(0),\n                balanceFormatted: '0.00',\n            };\n\n            if (account) {\n                const library = providerStore.providerStatus.library;\n\n                const balanceWei = await library.getBalance(account);\n                const balanceFormatted = formatBalanceTruncated(\n                    bnum(balanceWei),\n                    18,\n                    4,\n                    20\n                );\n\n                tokenMetadata = {\n                    address: address,\n                    symbol: 'ETH',\n                    name: 'Ether',\n                    decimals: 18,\n                    hasIcon: true,\n                    precision: 4,\n                    balanceBn: bnum(balanceWei),\n                    balanceFormatted: balanceFormatted,\n                    allowance: MAX_UINT,\n                };\n            }\n        } else {\n            try {\n                // symbol/decimal call will fail if not an actual token.\n                const tokenContract = providerStore.getContract(\n                    ContractTypes.TestToken,\n                    address\n                );\n\n                const tokenDecimals = await tokenContract.decimals();\n\n                let tokenSymbol;\n                let tokenName;\n                try {\n                    tokenSymbol = await tokenContract.symbol();\n                    tokenName = await tokenContract.name();\n                } catch (err) {\n                    console.log('[Token] Trying TokenBytes');\n                    const tokenContractBytes = providerStore.getContract(\n                        ContractTypes.TestTokenBytes,\n                        address\n                    );\n\n                    const tokenSymbolBytes = await tokenContractBytes.symbol();\n                    tokenSymbol = ethers.utils.parseBytes32String(\n                        tokenSymbolBytes\n                    );\n                    const tokenNameBytes = await tokenContractBytes.name();\n                    tokenName = ethers.utils.parseBytes32String(tokenNameBytes);\n                }\n\n                const precision = contractMetadataStore.getWhiteListedTokenPrecision(\n                    address\n                );\n\n                const balance = await this.getTokenBalance(\n                    address,\n                    account,\n                    tokenContract,\n                    tokenDecimals,\n                    precision\n                );\n\n                let allowance = bnum(0);\n                if (account) {\n                    allowance = this.getAllowance(\n                        address,\n                        account,\n                        proxyAddress\n                    );\n                    if (!allowance) {\n                        console.log(\n                            `[Token] Checking on-chain allowance ${tokenSymbol}`\n                        );\n                        const allowanceOnChain = await tokenContract.allowance(\n                            account,\n                            proxyAddress\n                        );\n                        allowance = bnum(allowanceOnChain.toString());\n                    }\n                    console.log(\n                        `[Token] Allowance ${tokenSymbol}: `,\n                        allowance.toString()\n                    );\n                }\n\n                tokenMetadata = {\n                    address: address,\n                    symbol: tokenSymbol,\n                    name: tokenName,\n                    decimals: tokenDecimals,\n                    hasIcon: true,\n                    precision: precision,\n                    balanceBn: balance.balanceBn,\n                    balanceFormatted: balance.balanceFormatted,\n                    allowance: allowance,\n                };\n            } catch (error) {\n                throw new Error('Non-Supported Token Address');\n            }\n        }\n        return tokenMetadata;\n    };\n}\n","import { BigNumber } from 'utils/bignumber';\n\nexport const BONE = new BigNumber(10).pow(18);\nconst BPOW_PRECISION = BONE.idiv(new BigNumber(10).pow(10));\n\nexport function calcOutGivenIn(\n    tokenBalanceIn: BigNumber,\n    tokenWeightIn: BigNumber,\n    tokenBalanceOut: BigNumber,\n    tokenWeightOut: BigNumber,\n    tokenAmountIn: BigNumber,\n    swapFee: BigNumber\n): BigNumber {\n    let weightRatio = bdiv(tokenWeightIn, tokenWeightOut);\n    let adjustedIn = BONE.minus(swapFee);\n    adjustedIn = bmul(tokenAmountIn, adjustedIn);\n    let y = bdiv(tokenBalanceIn, tokenBalanceIn.plus(adjustedIn));\n    let foo = bpow(y, weightRatio);\n    let bar = BONE.minus(foo);\n    let tokenAmountOut = bmul(tokenBalanceOut, bar);\n    return tokenAmountOut;\n}\n\nexport function calcInGivenOut(\n    tokenBalanceIn: BigNumber,\n    tokenWeightIn: BigNumber,\n    tokenBalanceOut: BigNumber,\n    tokenWeightOut: BigNumber,\n    tokenAmountOut: BigNumber,\n    swapFee: BigNumber\n) {\n    let weightRatio = bdiv(tokenWeightOut, tokenWeightIn);\n    let diff = tokenBalanceOut.minus(tokenAmountOut);\n    let y = bdiv(tokenBalanceOut, diff);\n    let foo = bpow(y, weightRatio);\n    foo = foo.minus(BONE);\n    let tokenAmountIn = BONE.minus(swapFee);\n    tokenAmountIn = bdiv(bmul(tokenBalanceIn, foo), tokenAmountIn);\n    return tokenAmountIn;\n}\n\nexport function calcSpotPrice(\n    tokenBalanceIn: BigNumber,\n    tokenWeightIn: BigNumber,\n    tokenBalanceOut: BigNumber,\n    tokenWeightOut: BigNumber,\n    swapFee: BigNumber\n) {\n    const numer = bdiv(tokenBalanceIn, tokenWeightIn);\n    const denom = bdiv(tokenBalanceOut, tokenWeightOut);\n    const ratio = bdiv(numer, denom);\n    const scale = bdiv(BONE, bsubSign(BONE, swapFee).res);\n    return bmul(ratio, scale);\n}\n\nexport function bmul(a: BigNumber, b: BigNumber): BigNumber {\n    let c0 = a.times(b);\n    let c1 = c0.plus(BONE.div(new BigNumber(2)));\n    let c2 = c1.idiv(BONE);\n    return c2;\n}\n\nexport function bdiv(a: BigNumber, b: BigNumber): BigNumber {\n    let c0 = a.times(BONE);\n    let c1 = c0.plus(b.div(new BigNumber(2)));\n    let c2 = c1.idiv(b);\n    return c2;\n}\n\nfunction btoi(a: BigNumber): BigNumber {\n    return a.idiv(BONE);\n}\n\nfunction bfloor(a: BigNumber): BigNumber {\n    return btoi(a).times(BONE);\n}\n\nfunction bsubSign(\n    a: BigNumber,\n    b: BigNumber\n): { res: BigNumber; bool: boolean } {\n    if (a.gte(b)) {\n        let res = a.minus(b);\n        let bool = false;\n        return { res, bool };\n    } else {\n        let res = b.minus(a);\n        let bool = true;\n        return { res, bool };\n    }\n}\n\nfunction bpowi(a: BigNumber, n: BigNumber): BigNumber {\n    let z = !n.modulo(new BigNumber(2)).eq(new BigNumber(0)) ? a : BONE;\n\n    for (\n        n = n.idiv(new BigNumber(2));\n        !n.eq(new BigNumber(0));\n        n = n.idiv(new BigNumber(2))\n    ) {\n        a = bmul(a, a);\n        if (!n.modulo(new BigNumber(2)).eq(new BigNumber(0))) {\n            z = bmul(z, a);\n        }\n    }\n    return z;\n}\n\nfunction bpow(base: BigNumber, exp: BigNumber): BigNumber {\n    let whole = bfloor(exp);\n    let remain = exp.minus(whole);\n    let wholePow = bpowi(base, btoi(whole));\n    if (remain.eq(new BigNumber(0))) {\n        return wholePow;\n    }\n\n    let partialResult = bpowApprox(base, remain, BPOW_PRECISION);\n    return bmul(wholePow, partialResult);\n}\n\nfunction bpowApprox(\n    base: BigNumber,\n    exp: BigNumber,\n    precision: BigNumber\n): BigNumber {\n    let a = exp;\n    let { res: x, bool: xneg } = bsubSign(base, BONE);\n    let term = BONE;\n    let sum = term;\n    let negative = false;\n\n    for (let i = 1; term.gte(precision); i++) {\n        let bigK = new BigNumber(i).times(BONE);\n        let { res: c, bool: cneg } = bsubSign(a, bigK.minus(BONE));\n        term = bmul(term, bmul(c, x));\n        term = bdiv(term, bigK);\n        if (term.eq(new BigNumber(0))) break;\n\n        if (xneg) negative = !negative;\n        if (cneg) negative = !negative;\n        if (negative) {\n            sum = sum.minus(term);\n        } else {\n            sum = sum.plus(term);\n        }\n    }\n\n    return sum;\n}\n","import { action, observable } from 'mobx';\nimport { bnum, scale, fromWei } from 'utils/helpers';\nimport RootStore from 'stores/Root';\nimport { BigNumber } from 'utils/bignumber';\nimport * as log from 'loglevel';\nimport { ContractTypes } from './Provider';\nimport { SwapMethods } from './SwapForm';\nimport { ethers } from 'ethers';\nimport { EtherKey } from './Token';\nimport { SorMultiSwap } from './Sor';\nimport { calcSpotPrice, bmul, bdiv } from '../utils/balancerCalcs';\n\nexport type SwapPreview = ExactAmountInPreview | ExactAmountOutPreview;\n\nexport interface ExactAmountOutPreview {\n    tokenAmountOut: BigNumber;\n    totalInput: BigNumber | null;\n    spotInput: BigNumber | null;\n    effectivePrice: BigNumber | null;\n    spotPrice: BigNumber | null;\n    expectedSlippage: BigNumber | null;\n    swaps: any[][];\n    sorSwapsFormatted: SorMultiSwap[];\n    validSwap: boolean;\n    error?: string;\n}\n\nexport interface ExactAmountInPreview {\n    tokenAmountIn: BigNumber;\n    totalOutput: BigNumber | null;\n    spotOutput: BigNumber | null;\n    effectivePrice: BigNumber | null;\n    spotPrice: BigNumber | null;\n    expectedSlippage: BigNumber | null;\n    swaps: any[][];\n    sorSwapsFormatted: SorMultiSwap[];\n    validSwap: boolean;\n    error?: string;\n}\n\nconst calcPrice = (amountIn, amountOut) => {\n    console.log('[calcPrice]', {\n        amountIn: amountIn.toString(),\n        amountOut: amountOut.toString(),\n        price: amountIn.div(amountOut).toString(),\n    });\n    return amountIn.div(amountOut);\n};\n\nconst calcExpectedSlippage = (\n    spotPrice: BigNumber,\n    effectivePrice: BigNumber\n) => {\n    const spotPercentage = spotPrice.div(effectivePrice).times(100);\n    console.log('[calcExpectedSlippage]', {\n        spotPrice: spotPrice.toString(),\n        effectivePrice: effectivePrice.toString(),\n        spotPercentage: spotPercentage.toString(),\n        expectedSlippage: bnum(100)\n            .minus(spotPercentage)\n            .toString(),\n    });\n\n    return bnum(100).minus(spotPercentage);\n};\n\nconst calcTotalSpotValue = async (\n    method: SwapMethods,\n    swaps: SorMultiSwap[],\n    allPools: any[]\n): Promise<BigNumber> => {\n    let totalValue = bnum(0);\n\n    for (let i = 0; i < swaps.length; i++) {\n        let sorMultiSwap = swaps[i];\n\n        let spotPrices = [];\n        // for each swap in sequence calculate spot price. spot price of sequence is product of all spot prices.\n        for (let j = 0; j < sorMultiSwap.sequence.length; j++) {\n            let swap = sorMultiSwap.sequence[j];\n            /*\n            console.log(\n                `!!!!!! Checking Swap:${i} Sequence:${j}, ${swap.pool}: ${\n                    swap.tokenInParam\n                }->${swap.tokenOutParam} Amount:${fromWei(swap.swapAmount)}`\n            );\n            */\n\n            const spotPrice = calcSpotPrice(\n                swap.balanceIn,\n                swap.weightIn,\n                swap.balanceOut,\n                swap.weightOut,\n                swap.swapFee\n            );\n            // console.log(`!!!!!!! swap[${i}:${j}] spotPrice: ${fromWei(spotPrice)}`);\n\n            spotPrices.push(spotPrice);\n        }\n\n        const spotPrice = spotPrices.reduce((a, b) => bmul(a, b));\n\n        if (method === SwapMethods.EXACT_IN) {\n            const swapAmount = sorMultiSwap.sequence[0].swapAmount;\n            totalValue = totalValue.plus(bdiv(bnum(swapAmount), spotPrice));\n        } else if (method === SwapMethods.EXACT_OUT) {\n            let swapAmount = sorMultiSwap.sequence[0].swapAmount;\n\n            if (sorMultiSwap.sequence.length > 1)\n                swapAmount = sorMultiSwap.sequence[1].swapAmount;\n\n            totalValue = totalValue.plus(bmul(bnum(swapAmount), spotPrice));\n            // console.log(`swap[${i}] spotPriceProduct: ${fromWei(spotPrice)} swapAmt: ${fromWei(swapAmount)}: tv:${fromWei(totalValue)}`);\n        }\n    }\n    // console.log(`!!!!!!! calcTotalSpotValue: ${fromWei(totalValue)}`)\n\n    return totalValue;\n};\n\nexport const calcMinAmountOut = (\n    spotValue: BigNumber,\n    slippagePercent: BigNumber\n): BigNumber => {\n    const result = spotValue\n        .minus(spotValue.times(slippagePercent.div(100)))\n        .integerValue(); // TODO - fix this to be fully integer math\n\n    console.log('[Min Out]', {\n        spotValue: spotValue.toString(),\n        slippagePercent: slippagePercent.toString(),\n        results: spotValue\n            .minus(spotValue.times(slippagePercent.div(100)))\n            .toString(),\n    });\n\n    return result.gt(0) ? result : bnum(0);\n};\n\nexport const calcMaxAmountIn = (\n    spotValue: BigNumber,\n    slippagePercent: BigNumber\n): BigNumber => {\n    const result = spotValue\n        .plus(spotValue.times(slippagePercent.div(100)))\n        .integerValue(); // TODO - fix this to be fully integer math\n\n    console.log('[Max In]', {\n        spotValue: spotValue.toString(),\n        slippagePercent: slippagePercent.toString(),\n        results: result.toString(),\n    });\n    return result;\n};\n\nexport function emptyExactAmountInPreview(\n    inputAmount,\n    e?: string\n): ExactAmountInPreview {\n    return {\n        tokenAmountIn: null,\n        totalOutput: null,\n        spotOutput: null,\n        effectivePrice: null,\n        spotPrice: null,\n        expectedSlippage: null,\n        swaps: null,\n        sorSwapsFormatted: null,\n        validSwap: false,\n        error: !!e ? e : undefined,\n    };\n}\n\nexport function emptyExactAmountOutPreview(\n    outputAmount,\n    e?: string\n): ExactAmountOutPreview {\n    return {\n        tokenAmountOut: null,\n        totalInput: null,\n        spotInput: null,\n        effectivePrice: null,\n        spotPrice: null,\n        expectedSlippage: null,\n        swaps: null,\n        sorSwapsFormatted: null,\n        validSwap: false,\n        error: !!e ? e : undefined,\n    };\n}\n\nexport default class ProxyStore {\n    @observable previewPending: boolean;\n    rootStore: RootStore;\n\n    constructor(rootStore) {\n        this.rootStore = rootStore;\n        this.previewPending = false;\n    }\n\n    isPreviewPending() {\n        return this.previewPending;\n    }\n\n    @action setPreviewPending(value) {\n        this.previewPending = value;\n    }\n\n    /*\n        Swap Methods - Action\n    */\n    @action batchSwapExactIn = async (\n        swaps: any[][],\n        tokenIn: string,\n        tokenAmountIn: BigNumber,\n        decimalsIn: number,\n        tokenOut: string,\n        minAmountOut: BigNumber,\n        decimalsOut: number\n    ) => {\n        const { providerStore, contractMetadataStore } = this.rootStore;\n        const proxyAddress = contractMetadataStore.getProxyAddress();\n\n        console.log(`batchSwapExactIn Swapping: ${tokenIn}->${tokenOut}`);\n        console.log(`Amt In: ${tokenAmountIn.toString()}`);\n        console.log(`Min Amt Out: ${fromWei(minAmountOut)}`);\n        console.log(`Swap sequences:`);\n        // console.log(`Decimals In: ${decimalsIn}`);\n        // console.log(`Decimals Out: ${decimalsOut}`);\n\n        swaps.forEach(swap => {\n            swap.forEach(sequence => {\n                console.log(\n                    `${sequence.pool}: ${sequence.tokenIn}->${\n                        sequence.tokenOut\n                    }, Amt:${fromWei(sequence.swapAmount)} Limit:${fromWei(\n                        sequence.limitReturnAmount\n                    )} MaxPrice:${fromWei(sequence.maxPrice)}`\n                );\n            });\n        });\n\n        if (tokenIn === EtherKey) {\n            tokenIn = '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE';\n\n            await providerStore.sendTransaction(\n                ContractTypes.ExchangeProxy,\n                proxyAddress,\n                'multihopBatchSwapExactIn',\n                [\n                    swaps,\n                    tokenIn,\n                    tokenOut,\n                    scale(tokenAmountIn, decimalsIn).toString(),\n                    minAmountOut.toString(),\n                ],\n                {\n                    value: ethers.utils.bigNumberify(\n                        scale(tokenAmountIn, decimalsIn).toString()\n                    ),\n                }\n            );\n        } else if (tokenOut === EtherKey) {\n            tokenOut = '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE';\n\n            await providerStore.sendTransaction(\n                ContractTypes.ExchangeProxy,\n                proxyAddress,\n                'multihopBatchSwapExactIn',\n                [\n                    swaps,\n                    tokenIn,\n                    tokenOut,\n                    scale(tokenAmountIn, decimalsIn).toString(),\n                    minAmountOut.toString(),\n                ]\n            );\n        } else {\n            await providerStore.sendTransaction(\n                ContractTypes.ExchangeProxy,\n                proxyAddress,\n                'multihopBatchSwapExactIn',\n                [\n                    swaps,\n                    tokenIn,\n                    tokenOut,\n                    scale(tokenAmountIn, decimalsIn).toString(),\n                    minAmountOut.toString(),\n                ]\n            );\n        }\n    };\n\n    @action batchSwapExactOut = async (\n        swaps: any[][],\n        tokenIn: string,\n        maxAmountIn: BigNumber,\n        decimalsIn: number,\n        tokenOut: string,\n        tokenAmountOut: BigNumber,\n        decimalsOut: number\n    ) => {\n        const { providerStore, contractMetadataStore } = this.rootStore;\n        const proxyAddress = contractMetadataStore.getProxyAddress();\n\n        console.log(`batchSwapExactOut Swapping: ${tokenIn}->${tokenOut}`);\n        console.log(`Max In: ${fromWei(maxAmountIn)}`);\n        console.log(`Amt Out: ${tokenAmountOut.toString()}`);\n        console.log(`Swap sequences:`);\n        // console.log(`Decimals In: ${decimalsIn}`);\n        // console.log(`Decimals Out: ${decimalsOut}`);\n\n        swaps.forEach(swap => {\n            swap.forEach(sequence => {\n                console.log(\n                    `${sequence.pool}: ${sequence.tokenIn}->${\n                        sequence.tokenOut\n                    }, Amt:${fromWei(sequence.swapAmount)} Limit:${fromWei(\n                        sequence.limitReturnAmount\n                    )} MaxPrice:${fromWei(sequence.maxPrice)}`\n                );\n            });\n        });\n\n        if (tokenIn === EtherKey) {\n            tokenIn = '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE';\n\n            await providerStore.sendTransaction(\n                ContractTypes.ExchangeProxy,\n                proxyAddress,\n                'multihopBatchSwapExactOut',\n                [swaps, tokenIn, tokenOut, maxAmountIn.toString()],\n                {\n                    value: ethers.utils.bigNumberify(maxAmountIn.toString()),\n                }\n            );\n        } else if (tokenOut === EtherKey) {\n            tokenOut = '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE';\n\n            await providerStore.sendTransaction(\n                ContractTypes.ExchangeProxy,\n                proxyAddress,\n                'multihopBatchSwapExactOut',\n                [swaps, tokenIn, tokenOut, maxAmountIn.toString()]\n            );\n        } else {\n            await providerStore.sendTransaction(\n                ContractTypes.ExchangeProxy,\n                proxyAddress,\n                'multihopBatchSwapExactOut',\n                [swaps, tokenIn, tokenOut, maxAmountIn.toString()]\n            );\n        }\n    };\n\n    calcEffectivePrice(amountIn: BigNumber, amountOut: BigNumber): BigNumber {\n        return amountIn.div(amountOut);\n    }\n\n    /*\n        Swap Methods - Preview\n    */\n    previewBatchSwapExactIn = async (\n        tokenIn: string,\n        tokenOut: string,\n        inputAmount: BigNumber,\n        inputDecimals: number\n    ): Promise<ExactAmountInPreview> => {\n        try {\n            const {\n                contractMetadataStore,\n                poolStore,\n                sorStore,\n                swapFormStore,\n            } = this.rootStore;\n\n            this.setPreviewPending(true);\n\n            if (poolStore.onChainPools.pools.length === 0) {\n                swapFormStore.setSwapObjection('Waiting For Pools To Load');\n\n                swapFormStore.showLoader = true;\n                await poolStore.onChainPoolsPromise;\n            }\n\n            const tokenAmountIn = scale(bnum(inputAmount), inputDecimals);\n\n            // Use WETH address for Ether\n            const tokenInToFind =\n                tokenIn === EtherKey\n                    ? contractMetadataStore.getWethAddress()\n                    : tokenIn;\n            const tokenOutToFind =\n                tokenOut === EtherKey\n                    ? contractMetadataStore.getWethAddress()\n                    : tokenOut;\n\n            console.log(\n                `[SOR] findBestSwapsMultiEps: ${tokenInToFind} ${tokenOutToFind} ${\n                    SwapMethods.EXACT_IN\n                } ${fromWei(tokenAmountIn)}`\n            );\n\n            const [totalOutput, sorSwaps] = await sorStore.findBestSwapsMulti(\n                SwapMethods.EXACT_IN,\n                tokenAmountIn,\n                sorStore.noPools,\n                sorStore.costOutputToken\n            );\n\n            const sorSwapsFormatted = await sorStore.formatSorSwaps(sorSwaps);\n\n            if (sorSwapsFormatted.length === 0) {\n                this.setPreviewPending(false);\n                return emptyExactAmountInPreview(\n                    inputAmount,\n                    'Insufficient liquidity on Balancer'\n                );\n            }\n\n            let spotOutput = await calcTotalSpotValue(\n                SwapMethods.EXACT_IN,\n                sorSwapsFormatted,\n                poolStore.onChainPools.pools\n            );\n\n            const spotPrice = calcPrice(tokenAmountIn, spotOutput);\n\n            console.log('[Spot Price Calc]', {\n                tokenAmountIn: tokenAmountIn.toString(),\n                spotOutput: spotOutput.toString(),\n            });\n\n            const effectivePrice = this.calcEffectivePrice(\n                tokenAmountIn,\n                totalOutput\n            );\n\n            const expectedSlippage = calcExpectedSlippage(\n                spotPrice,\n                effectivePrice\n            );\n\n            this.setPreviewPending(false);\n\n            return {\n                tokenAmountIn,\n                totalOutput,\n                spotOutput,\n                effectivePrice,\n                spotPrice,\n                expectedSlippage,\n                swaps: sorSwaps,\n                sorSwapsFormatted: sorSwapsFormatted,\n                validSwap: true,\n            };\n        } catch (e) {\n            log.error('[Error] previewSwapExactAmountIn', e);\n            this.setPreviewPending(false);\n            return emptyExactAmountInPreview(inputAmount, e.message);\n        }\n    };\n\n    previewBatchSwapExactOut = async (\n        tokenIn: string,\n        tokenOut: string,\n        outputAmount: BigNumber,\n        outputDecimals: number\n    ): Promise<ExactAmountOutPreview> => {\n        try {\n            this.setPreviewPending(true);\n            const {\n                contractMetadataStore,\n                poolStore,\n                sorStore,\n                swapFormStore,\n            } = this.rootStore;\n\n            if (poolStore.onChainPools.pools.length === 0) {\n                swapFormStore.setSwapObjection('Waiting For Pools To Load');\n\n                swapFormStore.showLoader = true;\n                await poolStore.onChainPoolsPromise;\n            }\n\n            const tokenAmountOut = scale(bnum(outputAmount), outputDecimals);\n\n            // Use WETH address for Ether\n            const tokenInToFind =\n                tokenIn === EtherKey\n                    ? contractMetadataStore.getWethAddress()\n                    : tokenIn;\n            const tokenOutToFind =\n                tokenOut === EtherKey\n                    ? contractMetadataStore.getWethAddress()\n                    : tokenOut;\n\n            console.log(\n                `[SOR] findBestSwapsMultiEps: ${tokenInToFind} ${tokenOutToFind} ${\n                    SwapMethods.EXACT_OUT\n                } ${fromWei(tokenAmountOut)}`\n            );\n\n            // sorSwaps is the unchanged info from SOR that can be directly passed to proxy transaction\n            const [totalInput, sorSwaps] = await sorStore.findBestSwapsMulti(\n                SwapMethods.EXACT_OUT,\n                tokenAmountOut,\n                sorStore.noPools,\n                sorStore.costInputToken\n            );\n\n            const sorSwapsFormatted = await sorStore.formatSorSwaps(sorSwaps);\n\n            if (sorSwapsFormatted.length === 0) {\n                this.setPreviewPending(false);\n                return emptyExactAmountOutPreview(\n                    outputAmount,\n                    'Insufficient liquidity on Balancer'\n                );\n            }\n\n            const spotInput = await calcTotalSpotValue(\n                SwapMethods.EXACT_OUT,\n                sorSwapsFormatted,\n                poolStore.onChainPools.pools\n            );\n\n            console.log('[Spot Price Calc]', {\n                tokenAmountOut: tokenAmountOut.toString(),\n                totalInputSpot: spotInput.toString(),\n            });\n            const spotPrice = calcPrice(tokenAmountOut, spotInput);\n\n            const effectivePrice = this.calcEffectivePrice(\n                tokenAmountOut,\n                totalInput\n            );\n\n            console.log('[Eff Price Calc]', {\n                tokenAmountOut: tokenAmountOut.toString(),\n                totalInput: totalInput.toString(),\n                effectivePrice: effectivePrice.toString(),\n            });\n\n            const expectedSlippage = calcExpectedSlippage(\n                effectivePrice,\n                spotPrice\n            );\n\n            if (totalInput.isNaN()) {\n                throw new Error('NaN total calculated input');\n            }\n\n            this.setPreviewPending(false);\n            return {\n                tokenAmountOut,\n                totalInput,\n                spotInput,\n                effectivePrice,\n                spotPrice,\n                expectedSlippage,\n                swaps: sorSwaps,\n                sorSwapsFormatted: sorSwapsFormatted,\n                validSwap: true,\n            };\n        } catch (e) {\n            log.error('[Error] previewSwapExactAmountOut', e);\n            this.setPreviewPending(false);\n            return emptyExactAmountOutPreview(outputAmount, e.message);\n        }\n    };\n}\n","import { action, observable } from 'mobx';\nimport RootStore from 'stores/Root';\n\nexport enum ErrorIds {\n    SWAP_FORM_STORE,\n}\n\nexport enum ErrorCodes {\n    NO_ERROR,\n    GENERIC_TX_FAILURE,\n    BALANCER_MAX_RATIO_IN,\n    NO_WALLET_FOUND,\n    INSUFFICIENT_BALANCE_FOR_SWAP,\n    INSUFFICIENT_APPROVAL_FOR_SWAP,\n}\n\nexport const ERROR_MESSAGES = [\n    'No Error',\n    'Transaction Failed',\n    'Balancer Max in Ratio',\n    'No Ethereum wallet found',\n    'Insufficient Balance',\n    'Enable Input Token',\n];\n\nexport interface BalancerError {\n    code: ErrorCodes;\n    message: string;\n}\n\ninterface BalancerErrorMap {\n    [index: number]: BalancerError | undefined;\n}\n\nexport default class ErrorStore {\n    rootStore: RootStore;\n    @observable activeErrors: BalancerErrorMap;\n\n    constructor(rootStore) {\n        this.activeErrors = {} as BalancerErrorMap;\n        this.rootStore = rootStore;\n    }\n\n    getActiveError(id: ErrorIds): BalancerError | undefined {\n        return this.activeErrors[id];\n    }\n\n    @action setActiveError(id: ErrorIds, code: ErrorCodes) {\n        if (code === ErrorCodes.NO_ERROR) {\n            this.activeErrors[id] = undefined;\n        } else {\n            this.activeErrors[id] = {\n                code,\n                message: ERROR_MESSAGES[code],\n            };\n        }\n    }\n}\n","import { action, observable } from 'mobx';\nimport RootStore from 'stores/Root';\nimport { supportedChainId } from '../provider/connectors';\nimport { InputValidationStatus, SwapMethods } from './SwapForm';\n\nexport default class BlockchainFetchStore {\n    @observable activeFetchLoop: any;\n    rootStore: RootStore;\n\n    constructor(rootStore) {\n        this.rootStore = rootStore;\n    }\n\n    @action blockchainFetch(accountSwitchOverride?: boolean) {\n        const {\n            providerStore,\n            tokenStore,\n            contractMetadataStore,\n        } = this.rootStore;\n\n        const active = providerStore.providerStatus.active;\n        const chainId = providerStore.providerStatus.activeChainId;\n        const library = providerStore.providerStatus.library;\n        const account = providerStore.providerStatus.account;\n\n        if (active && chainId === supportedChainId) {\n            library\n                .getBlockNumber()\n                .then(blockNumber => {\n                    const lastCheckedBlock = providerStore.getCurrentBlockNumber();\n\n                    const doFetch =\n                        blockNumber !== lastCheckedBlock ||\n                        accountSwitchOverride;\n\n                    if (doFetch) {\n                        console.log('[Fetch Loop] Fetch Blockchain Data', {\n                            lastCheckedBlock,\n                            blockNumber,\n                            chainId,\n                            account,\n                        });\n\n                        // Using on-chain balances. These may change so need to be updated.\n                        // poolStore.fetchOnchainPools();\n\n                        // Set block number\n                        providerStore.setCurrentBlockNumber(blockNumber);\n\n                        // Get global blockchain data\n                        // None\n\n                        // Get user-specific blockchain data\n                        if (account) {\n                            providerStore\n                                .fetchUserBlockchainData(account)\n                                .then(results => {\n                                    // Update preview when account changes\n                                    if (accountSwitchOverride) {\n                                        this.updateSwapPreviewForActiveAccount();\n                                    }\n                                })\n                                .catch(e => {\n                                    console.log(e);\n                                });\n                        } else {\n                            tokenStore.fetchOnChainTokenDecimals(\n                                contractMetadataStore.getTrackedTokenAddresses()\n                            );\n                        }\n                    }\n                })\n                .catch(error => {\n                    console.log('[Fetch Loop Failure]', {\n                        providerStore,\n                        forceFetch: accountSwitchOverride,\n                        chainId,\n                        account,\n                        library,\n                        error,\n                    });\n                    providerStore.setCurrentBlockNumber(undefined);\n                });\n        } else {\n            console.log(`[BlockchainFetch] Aborting fetch. `, {\n                active,\n                chainId,\n                supportedChainId,\n            });\n        }\n    }\n\n    updateSwapPreviewForActiveAccount() {\n        const { swapFormStore } = this.rootStore;\n\n        const { swapMethod, inputAmount, outputAmount } = swapFormStore.inputs;\n\n        if (swapMethod === SwapMethods.EXACT_IN) {\n            const inputStatus = swapFormStore.validateSwapValue(inputAmount);\n            if (inputStatus === InputValidationStatus.VALID) {\n                swapFormStore.refreshExactAmountInPreview();\n            } else {\n                swapFormStore.refreshInvalidInputAmount(\n                    inputAmount,\n                    inputStatus\n                );\n            }\n        } else if (swapMethod === SwapMethods.EXACT_OUT) {\n            const inputStatus = swapFormStore.validateSwapValue(outputAmount);\n            if (inputStatus === InputValidationStatus.VALID) {\n                swapFormStore.refreshExactAmountOutPreview();\n            } else {\n                swapFormStore.refreshInvalidOutputAmount(\n                    outputAmount,\n                    inputStatus\n                );\n            }\n        }\n    }\n}\n","import { action, observable } from 'mobx';\nimport RootStore from 'stores/Root';\n\nexport default class DropdownStore {\n    @observable walletDropdownVisible: boolean;\n    rootStore: RootStore;\n\n    constructor(rootStore) {\n        this.rootStore = rootStore;\n        this.walletDropdownVisible = false;\n    }\n\n    @action toggleWalletDropdown() {\n        this.walletDropdownVisible = !this.walletDropdownVisible;\n    }\n\n    @action setWalletDropdownVisible(visible: boolean) {\n        this.walletDropdownVisible = visible;\n    }\n}\n","/* Main app configs go here */\nexport const appConfig = {\n    name: 'Balancer',\n    shortName: 'Balancer',\n    description: '',\n    splashScreenBackground: '#ffffff',\n};\n","import { createMuiTheme } from '@material-ui/core/styles';\nimport { getStyles } from './lib-style-helpers';\n\nconst colors = getStyles(['error', 'primary', 'secondary']);\n\nconst theme = createMuiTheme({\n    palette: {\n        primary: {\n            main: colors.primary,\n        },\n        secondary: {\n            main: colors.secondary,\n        },\n        error: {\n            main: colors.error,\n        },\n    },\n});\n\nexport default theme;\n","export function getStyles(key) {\n    /* eslint-disable */\n    const variables = require('sass-extract-loader?{\"plugins\":[\"sass-extract-js\"]}!../../configs/theme/config-styles.scss');\n\n    if (key instanceof Array) {\n        const returnObj = {};\n\n        for (let i = 0; i < key.length; i += 1) {\n            const styleKey = key[i];\n\n            if (variables[styleKey]) {\n                const style = variables[styleKey];\n\n                returnObj[styleKey] = style;\n            }\n        }\n\n        return returnObj;\n    } else if (typeof key === 'string' && variables[key]) {\n        return variables[key];\n    }\n\n    return null;\n}\n","import registry from 'assets/generated/dex/registry.homestead.json';\nimport registryKovan from 'assets/generated/dex/registry.kovan.json';\nimport { getSupportedChainName } from '../provider/connectors';\n\nfunction getContracts(chainName: string) {\n    if (chainName === 'mainnet') {\n        return {\n            bFactory: '0x9424B1412450D0f8Fc2255FAf6046b98213B76Bd',\n            proxy: '0x3E66B66Fd1d0b02fDa6C811Da9E0547970DB2f21',\n            weth: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2',\n            multicall: '0xeefBa1e63905eF1D7ACbA5a8513c70307C1cE441',\n        };\n    }\n    if (chainName === 'kovan') {\n        return {\n            bFactory: '0x8f7F78080219d4066A8036ccD30D588B416a40DB',\n            proxy: '0x2641f150669739986CDa3ED6860DeD44BC3Cda5d',\n            weth: '0xd0A1E359811322d97991E03f863a0C30C2cF029C',\n            multicall: '0x2cc8688C5f75E365aaEEb4ea8D6a480405A48D2A',\n        };\n    }\n    return {};\n}\n\nfunction getAssets(chainName: string) {\n    if (chainName === 'mainnet') {\n        return registry;\n    }\n    if (chainName === 'kovan') {\n        return registryKovan;\n    }\n    return {\n        tokens: {},\n        untrusted: [],\n    };\n}\n\nconst chainName = getSupportedChainName();\nconst contracts = getContracts(chainName);\nconst assets = getAssets(chainName);\n\nexport { contracts, assets };\n","import { TokenBalance, UserAllowance } from '../Token';\nimport { TokenPairData } from '../Pool';\n\nexport enum AsyncStatus {\n    SUCCESS,\n    STALE,\n    TIMEOUT,\n    FAILURE,\n}\n\nexport interface TokenBalanceFetchRequest {\n    chainId: number;\n    tokenAddress: string;\n    account: string;\n    fetchBlock: number;\n}\n\nexport class TokenBalanceFetch {\n    status: AsyncStatus;\n    request: TokenBalanceFetchRequest;\n    payload: TokenBalance | undefined;\n\n    constructor({ status, request, payload }) {\n        this.status = status;\n        this.request = request;\n        this.payload = payload;\n    }\n}\n\nexport interface UserAllowanceFetchRequest {\n    chainId: number;\n    tokenAddress: string;\n    owner: string;\n    spender: string;\n    fetchBlock: number;\n}\n\nexport class UserAllowanceFetch {\n    status: AsyncStatus;\n    request: UserAllowanceFetchRequest;\n    payload: UserAllowance | undefined;\n\n    constructor({ status, request, payload }) {\n        this.status = status;\n        this.request = request;\n        this.payload = payload;\n    }\n}\n\nexport interface TokenPairsFetchRequest {\n    chainId: number;\n    tokenAddress: string;\n    fetchBlock: number;\n}\n\nexport class TokenPairsFetch {\n    status: AsyncStatus;\n    request: TokenPairsFetchRequest;\n    payload: TokenPairData | undefined;\n\n    constructor({ status, request, payload }) {\n        this.status = status;\n        this.request = request;\n        this.payload = payload;\n    }\n}\n","import { action, observable } from 'mobx';\nimport RootStore from 'stores/Root';\nimport { contracts, assets } from 'configs';\nimport { BigNumber } from 'utils/bignumber';\nimport { toChecksum } from '../utils/helpers';\nimport { EtherKey } from './Token';\n\nexport interface ContractMetadata {\n    bFactory: string;\n    proxy: string;\n    weth: string;\n    multicall: string;\n    tokens: TokenMetadata[];\n    untrusted: string[];\n}\n\nexport interface TokenMetadata {\n    address: string;\n    symbol: string;\n    name: string;\n    decimals: number;\n    hasIcon: boolean;\n    precision: number;\n    isSupported: boolean;\n    allowance: BigNumber;\n}\n\nexport default class ContractMetadataStore {\n    @observable contractMetadata: ContractMetadata;\n    rootStore: RootStore;\n\n    constructor(rootStore) {\n        this.rootStore = rootStore;\n        this.contractMetadata = {} as ContractMetadata;\n        this.loadWhitelistedTokenMetadata();\n    }\n\n    // Take the data from the JSON and get it into the store, so we access it just like other data\n    @action loadWhitelistedTokenMetadata() {\n        const { tokens, untrusted } = assets;\n\n        const contractMetadata = {\n            bFactory: contracts.bFactory,\n            proxy: contracts.proxy,\n            weth: contracts.weth,\n            multicall: contracts.multicall,\n            tokens: [] as TokenMetadata[],\n            untrusted,\n        };\n\n        Object.keys(tokens).forEach(tokenAddress => {\n            const token = tokens[tokenAddress];\n            const { address, symbol, name, precision, hasIcon } = token;\n            contractMetadata.tokens.push({\n                address,\n                symbol,\n                name,\n                decimals: 18,\n                hasIcon,\n                precision,\n                isSupported: true,\n                allowance: new BigNumber(0),\n            });\n        });\n\n        this.contractMetadata = contractMetadata;\n    }\n\n    async addToken(tokenAddr, account) {\n        const { tokenStore, swapFormStore } = this.rootStore;\n        const existingTokens = this.contractMetadata.tokens || undefined;\n\n        if (tokenAddr === EtherKey) return;\n\n        let isToken = existingTokens.filter(value => {\n            if (value.address === EtherKey) return false;\n            return toChecksum(tokenAddr) === toChecksum(value.address);\n        });\n\n        if (isToken.length === 0) {\n            console.log(`Adding TOken: ${tokenAddr}`);\n            const tokenMetadata = await tokenStore.fetchOnChainTokenMetadata(\n                tokenAddr,\n                account\n            );\n\n            console.log(`Allowance: ${tokenMetadata.allowance.toString()}`);\n            tokenStore.setBalances(\n                [toChecksum(tokenAddr)],\n                [tokenMetadata.balanceBn],\n                account,\n                20000\n            );\n            tokenStore.setAllowances(\n                [tokenAddr],\n                account,\n                this.getProxyAddress(),\n                [tokenMetadata.allowance],\n                20000\n            );\n\n            this.contractMetadata.tokens.push({\n                address: tokenAddr,\n                symbol: tokenMetadata.symbol,\n                name: tokenMetadata.name,\n                decimals: tokenMetadata.decimals,\n                hasIcon: tokenMetadata.hasIcon,\n                precision: tokenMetadata.precision,\n                isSupported: true,\n                allowance: tokenMetadata.allowance,\n            });\n\n            swapFormStore.updateSelectedTokenMetaData(account);\n        }\n    }\n\n    getProxyAddress(): string {\n        const proxyAddress = this.contractMetadata.proxy;\n        if (!proxyAddress) {\n            throw new Error(\n                '[Invariant] Trying to get non-loaded static address'\n            );\n        }\n        return proxyAddress;\n    }\n\n    getWethAddress(): string {\n        const address = this.contractMetadata.weth;\n        if (!address) {\n            throw new Error(\n                '[Invariant] Trying to get non-loaded static address'\n            );\n        }\n        return address;\n    }\n\n    getMultiAddress(): string {\n        const multiAddress = this.contractMetadata.multicall;\n        if (!multiAddress) {\n            throw new Error(\n                '[Invariant] Trying to get non-loaded static address'\n            );\n        }\n        return multiAddress;\n    }\n\n    getUntrustedTokens(): string[] {\n        return this.contractMetadata.untrusted;\n    }\n\n    // Used for asset options\n    getFilteredTokenMetadata(filter: string): TokenMetadata[] {\n        const tokens = this.contractMetadata.tokens || undefined;\n\n        if (!tokens) {\n            throw new Error(\n                'Attempting to get user balances for untracked chainId'\n            );\n        }\n\n        let filteredMetadata: TokenMetadata[] = [];\n\n        if (filter === 'ether') {\n            filteredMetadata = tokens.filter(value => {\n                return value.address === filter;\n            });\n        } else if (filter.indexOf('0x') === 0) {\n            //Search by address\n            filteredMetadata = tokens.filter(value => {\n                return value.address.toLowerCase() === filter.toLowerCase();\n            });\n        } else {\n            //Search by symbol\n            filteredMetadata = tokens.filter(value => {\n                const valueString = value.symbol.toLowerCase();\n                filter = filter.toLowerCase();\n                return valueString.includes(filter);\n            });\n        }\n\n        return filteredMetadata;\n    }\n\n    // Provider uses this to get balances\n    getTrackedTokenAddresses(): string[] {\n        const { assetOptionsStore } = this.rootStore;\n        const tokens = this.contractMetadata.tokens;\n        let tokenList = tokens.map(token => token.address);\n        if (assetOptionsStore.tokenAssetData)\n            tokenList.push(assetOptionsStore.tokenAssetData.address);\n\n        return tokenList;\n    }\n\n    getWhiteListedTokenPrecision(address: string): number {\n        const tokenList = this.contractMetadata.tokens.filter(\n            token => token.isSupported\n        );\n        const tokenUrl = tokenList.find(t => t.address === address);\n        if (tokenUrl) return tokenUrl.precision;\n        else return 4;\n    }\n\n    getDaiAddress(): string {\n        return this.contractMetadata.tokens.filter(\n            token => token.isSupported\n        )[1].address;\n    }\n\n    getEthAddress(): string {\n        return this.contractMetadata.tokens.filter(\n            token => token.isSupported\n        )[0].address;\n    }\n\n    setTokenDecimals(address: string, decimals: number) {\n        const tokenUrl = this.contractMetadata.tokens.find(\n            t => t.address === address\n        );\n        if (tokenUrl) tokenUrl.decimals = decimals;\n    }\n}\n","import { action, observable } from 'mobx';\nimport RootStore from 'stores/Root';\n\nexport default class AppSettingsStore {\n    @observable darkMode: boolean;\n    rootStore: RootStore;\n\n    constructor(rootStore) {\n        this.rootStore = rootStore;\n        this.darkMode = false;\n    }\n\n    @action toggleDarkMode() {\n        this.darkMode = !this.darkMode;\n    }\n\n    @action setDarkMode(visible: boolean) {\n        this.darkMode = visible;\n    }\n}\n","import { BigNumber } from 'utils/bignumber';\n\nexport default class CostCalculator {\n    gasPrice: BigNumber;\n    gasPerTrade: BigNumber;\n    outTokenEthPrice: BigNumber;\n    costPerTrade: BigNumber;\n    costOutputToken: BigNumber;\n\n    constructor(params: {\n        gasPrice: BigNumber;\n        gasPerTrade: BigNumber;\n        outTokenEthPrice: BigNumber;\n    }) {\n        const { gasPrice, gasPerTrade, outTokenEthPrice } = params;\n        this.gasPrice = gasPrice;\n        this.gasPerTrade = gasPerTrade;\n        this.outTokenEthPrice = outTokenEthPrice;\n        this.costPerTrade = gasPrice.times(gasPerTrade);\n        this.costOutputToken = this.costPerTrade.times(outTokenEthPrice);\n    }\n\n    getCostOutputToken(): BigNumber {\n        return this.costOutputToken;\n    }\n}\n","import { action } from 'mobx';\nimport RootStore from 'stores/Root';\nimport CostCalculator from '../utils/CostCalculator';\nimport { bnum, fromWei, toChecksum } from 'utils/helpers';\nimport { EtherKey } from './Token';\nimport {\n    filterPoolsWithTokensDirect,\n    filterPoolsWithTokensMultihop,\n    getTokenPairsMultiHop,\n    parsePoolData,\n    processPaths,\n    processEpsOfInterestMultiHop,\n    smartOrderRouterMultiHopEpsOfInterest,\n    filterAllPools,\n    getCostOutputToken,\n} from '@balancer-labs/sor';\nimport { BigNumber } from '../utils/bignumber';\nimport { SwapMethods } from './SwapForm';\nimport { TokenPairs } from './Pool';\nimport ContractMetadataStore from './ContractMetadata';\n// import { calcInGivenOut } from '../utils/balancerCalcs';\n\ninterface MultiSwap {\n    pool: string;\n    tokenInParam: string;\n    tokenOutParam: string;\n    maxPrice: string;\n    swapAmount: string;\n    limitReturnAmount: string;\n    id?: string;\n    decimalsIn?: number;\n    decimalsOut?: number;\n    balanceIn?: BigNumber;\n    balanceOut?: BigNumber;\n    weightIn?: BigNumber;\n    weightOut?: BigNumber;\n    swapFee?: BigNumber;\n}\n\nexport interface SorMultiSwap {\n    sequence: MultiSwap[];\n}\n\nexport const sorTokenPairs = async (\n    tokenAddress: string,\n    contractMetadataStore: ContractMetadataStore,\n    allPools: any[]\n): Promise<TokenPairs> => {\n    let [allTokensSet] = filterAllPools(allPools);\n    let [, allTokenPairs] = await getTokenPairsMultiHop(\n        tokenAddress.toLowerCase(),\n        allTokensSet\n    );\n    let tokenPairs: TokenPairs = new Set<string>();\n    const sanitizedWeth = toChecksum(contractMetadataStore.getWethAddress());\n    allTokenPairs.forEach(token => {\n        const sanitizedToken = toChecksum(token);\n\n        if (!tokenPairs.has(sanitizedToken)) {\n            tokenPairs.add(sanitizedToken);\n        }\n\n        // Add Ether along with WETH\n        if (sanitizedToken === sanitizedWeth && !tokenPairs.has(EtherKey)) {\n            tokenPairs.add(EtherKey);\n        }\n    });\n\n    return tokenPairs;\n};\n\nexport default class SorStore {\n    costCalculator: CostCalculator;\n    private rootStore: RootStore;\n    private processedPools: any;\n    private processedPathsIn: any;\n    private processedPathsOut: any;\n    private epsOfInterestIn: any;\n    private epsOfInterestOut: any;\n    noPools: number;\n    costOutputToken: BigNumber;\n    costInputToken: BigNumber;\n\n    constructor(rootStore) {\n        this.rootStore = rootStore;\n        this.processedPools = null;\n        this.processedPathsIn = null;\n        this.processedPathsOut = null;\n        this.epsOfInterestIn = null;\n        this.epsOfInterestOut = null;\n        this.costCalculator = new CostCalculator({\n            gasPrice: bnum(0),\n            gasPerTrade: bnum(0),\n            outTokenEthPrice: bnum(0),\n        });\n        this.noPools = Number(process.env.REACT_APP_MAX_POOLS || 4);\n        this.costOutputToken = bnum(0);\n        this.costInputToken = bnum(0);\n        // TODO: Should we fetchPathData on a timer incase user has window open without refreshing?\n    }\n\n    @action async fetchPathData(inputToken, outputToken) {\n        const {\n            contractMetadataStore,\n            poolStore,\n            swapFormStore,\n            providerStore,\n            assetOptionsStore,\n        } = this.rootStore;\n\n        if (inputToken !== '' && outputToken !== '') {\n            console.log(`[SOR] fetchPathData(${inputToken} ${outputToken})`);\n\n            // Use WETH address for Ether\n            if (inputToken === EtherKey)\n                inputToken = contractMetadataStore.getWethAddress();\n\n            if (outputToken === EtherKey)\n                outputToken = contractMetadataStore.getWethAddress();\n\n            if (\n                poolStore.onChainPools.pools.length === 0 &&\n                poolStore.poolsList.pools.length === 0\n            ) {\n                console.log(\n                    `[SOR] fetchPathData, No Pools Loaded, Can't Fetch Paths`\n                );\n                return;\n            }\n\n            // Waits for on-chain pools to finish loading\n            await poolStore.onChainPoolsPromise;\n\n            await this.getPathData(\n                poolStore.onChainPools,\n                inputToken,\n                outputToken\n            );\n\n            const library = providerStore.providerStatus.library;\n\n            let filteredWhitelistedTokens = contractMetadataStore.getFilteredTokenMetadata(\n                outputToken\n            );\n\n            let outPutTokenDecimals: number = 18;\n            if (filteredWhitelistedTokens.length === 0) {\n                if (assetOptionsStore.tokenAssetData) {\n                    if (\n                        assetOptionsStore.tokenAssetData.address === outputToken\n                    ) {\n                        outPutTokenDecimals = Number(\n                            assetOptionsStore.tokenAssetData.decimals.toString()\n                        );\n                    }\n                }\n            } else {\n                outPutTokenDecimals = Number(\n                    filteredWhitelistedTokens[0].decimals.toString()\n                );\n            }\n\n            this.costOutputToken = await this.getCostOutputToken(\n                outputToken,\n                outPutTokenDecimals,\n                bnum(process.env.REACT_APP_GAS_PRICE || 30000000000),\n                bnum(process.env.REACT_APP_SWAP_COST || 100000),\n                library\n            );\n\n            filteredWhitelistedTokens = contractMetadataStore.getFilteredTokenMetadata(\n                inputToken\n            );\n\n            let inputTokenDecimals: number = 18;\n            if (filteredWhitelistedTokens.length === 0) {\n                if (assetOptionsStore.tokenAssetData) {\n                    if (\n                        assetOptionsStore.tokenAssetData.address === inputToken\n                    ) {\n                        inputTokenDecimals = Number(\n                            assetOptionsStore.tokenAssetData.decimals.toString()\n                        );\n                    }\n                }\n            } else {\n                inputTokenDecimals = Number(\n                    filteredWhitelistedTokens[0].decimals.toString()\n                );\n            }\n\n            this.costInputToken = await this.getCostOutputToken(\n                inputToken,\n                inputTokenDecimals,\n                bnum(process.env.REACT_APP_GAS_PRICE || 30000000000),\n                bnum(process.env.REACT_APP_SWAP_COST || 100000),\n                library\n            );\n\n            swapFormStore.showLoader = false;\n\n            // This will update any existing input values for new paths\n            const inputValue = swapFormStore.getActiveInputValue();\n            swapFormStore.refreshSwapFormPreview(\n                inputValue,\n                swapFormStore.inputs.swapMethod\n            );\n\n            console.log(`[SOR] fetchPathData() On-Chain Path Data Loaded`);\n        }\n    }\n\n    @action formatSorSwaps = async (\n        sorSwaps: any[][]\n    ): Promise<SorMultiSwap[]> => {\n        const { poolStore } = this.rootStore;\n\n        let formattedSorSwaps: SorMultiSwap[] = [];\n\n        // let maxPrice = MAX_UINT.toString();\n        // let limitReturnAmount = '0';\n        // let limitReturnAmount = maxPrice;\n\n        // If subgraph has failed we must wait for on-chain balance info to be loaded.\n        if (poolStore.onChainPools.pools.length === 0) {\n            console.log(`[SOR] Backup - Must Wait For On-Chain Balances.`);\n            await poolStore.onChainPoolsPromise;\n            console.log(`[SOR] Backup - On-Chain Balances Loaded.`);\n        }\n\n        let swapDebug = [];\n\n        for (let i = 0; i < sorSwaps.length; i++) {\n            let sequence = sorSwaps[i];\n            let sorMultiSwap: SorMultiSwap = { sequence: [] };\n\n            let seqDebug = [];\n\n            for (let j = 0; j < sequence.length; j++) {\n                let swap = sequence[j];\n                seqDebug.push(swap);\n                // swap.maxPrice = maxPrice;\n                // swap.limitReturnAmount = limitReturnAmount;\n                console.log(\n                    `Swap:${i} Sequence:${j}, ${swap.pool}: ${swap.tokenIn}->${\n                        swap.tokenOut\n                    } Amt:${fromWei(swap.swapAmount)} maxPrice:${\n                        swap.maxPrice\n                    } limitReturn:${swap.limitReturnAmount}`\n                );\n\n                // Even if we use on-chain backup we need to get decimals from backup as not retrieved by SOR\n                let pool = poolStore.findPoolTokenInfo(\n                    swap.pool,\n                    swap.tokenIn,\n                    swap.tokenOut\n                );\n\n                /*\n                let inCheck = calcInGivenOut(\n                    pool.balanceIn,\n                    pool.weightIn,\n                    pool.balanceOut,\n                    pool.weightOut,\n                    swap.swapAmount,\n                    pool.swapFee\n                )\n\n                console.log(`!!!!!!! inCheck: ${fromWei(inCheck)}`)\n                */\n\n                let multiSwap: MultiSwap = {\n                    pool: swap.pool,\n                    tokenInParam: swap.tokenIn,\n                    tokenOutParam: swap.tokenOut,\n                    maxPrice: swap.maxPrice,\n                    swapAmount: swap.swapAmount,\n                    limitReturnAmount: swap.limitReturnAmount,\n                    id: pool.id,\n                    decimalsIn: pool.decimalsIn,\n                    decimalsOut: pool.decimalsOut,\n                    balanceIn: pool.balanceIn,\n                    balanceOut: pool.balanceOut,\n                    weightIn: pool.weightIn,\n                    weightOut: pool.weightOut,\n                    swapFee: pool.swapFee,\n                };\n\n                sorMultiSwap.sequence.push(multiSwap);\n            }\n\n            swapDebug.push(seqDebug);\n\n            formattedSorSwaps.push(sorMultiSwap);\n        }\n\n        console.log(swapDebug);\n\n        return formattedSorSwaps;\n    };\n\n    private getPathData = async (\n        Pools,\n        InputToken,\n        OutputToken\n    ): Promise<void> => {\n        let [pools, pathData] = await this.loadPathData(\n            Pools,\n            InputToken,\n            OutputToken\n        );\n\n        this.processedPools = pools;\n        this.processedPathsIn = processPaths(pathData, pools, 'swapExactIn');\n\n        this.epsOfInterestIn = processEpsOfInterestMultiHop(\n            this.processedPathsIn,\n            'swapExactIn',\n            this.noPools\n        );\n\n        this.processedPathsOut = processPaths(pathData, pools, 'swapExactOut');\n\n        this.epsOfInterestOut = processEpsOfInterestMultiHop(\n            this.processedPathsOut,\n            'swapExactOut',\n            this.noPools\n        );\n    };\n\n    loadPathData = async (\n        allPools: any,\n        tokenIn: string,\n        tokenOut: string\n    ): Promise<any[]> => {\n        tokenIn = tokenIn.toLowerCase();\n        tokenOut = tokenOut.toLowerCase();\n\n        let [, allPoolsNonZeroBalances] = filterAllPools(allPools);\n\n        const directPools = await filterPoolsWithTokensDirect(\n            allPoolsNonZeroBalances,\n            tokenIn,\n            tokenOut\n        );\n\n        let mostLiquidPoolsFirstHop, mostLiquidPoolsSecondHop, hopTokens;\n        [\n            mostLiquidPoolsFirstHop,\n            mostLiquidPoolsSecondHop,\n            hopTokens,\n        ] = await filterPoolsWithTokensMultihop(\n            allPoolsNonZeroBalances,\n            tokenIn,\n            tokenOut\n        );\n\n        let pools, pathData;\n        [pools, pathData] = parsePoolData(\n            directPools,\n            tokenIn,\n            tokenOut,\n            mostLiquidPoolsFirstHop,\n            mostLiquidPoolsSecondHop,\n            hopTokens\n        );\n\n        return [pools, pathData];\n    };\n\n    // User SOR to find all swaps including multi-hop\n    findBestSwapsMulti = async (\n        swapType: SwapMethods,\n        swapAmount: BigNumber,\n        maxPools: number,\n        returnTokenCostPerPool: BigNumber\n    ): Promise<[BigNumber, any[][]]> => {\n        let processedPaths = this.processedPathsIn;\n        let epsOfInterest = this.epsOfInterestIn;\n\n        if (swapType === SwapMethods.EXACT_OUT) {\n            processedPaths = this.processedPathsOut;\n            epsOfInterest = this.epsOfInterestOut;\n        }\n\n        const [sorSwaps, totalReturn] = smartOrderRouterMultiHopEpsOfInterest(\n            JSON.parse(JSON.stringify(this.processedPools)),\n            processedPaths,\n            swapType,\n            swapAmount,\n            maxPools,\n            returnTokenCostPerPool,\n            epsOfInterest\n        );\n\n        return [totalReturn, sorSwaps];\n    };\n\n    getCostOutputToken = async (\n        TokenAddr: string,\n        TokenDecimals: number,\n        GasPriceWei: BigNumber,\n        SwapGasCost: BigNumber,\n        Provider: any\n    ): Promise<BigNumber> => {\n        // console.log(`!!!!!!! COST: `, TokenAddr, TokenDecimals, GasPriceWei.toString(), SwapGasCost.toString())\n        const cost = await getCostOutputToken(\n            TokenAddr,\n            TokenDecimals,\n            GasPriceWei,\n            SwapGasCost,\n            Provider\n        );\n        console.log(`[SOR] costOutputToken: ${cost.toString()}`);\n        return cost;\n    };\n}\n","import * as allPools from 'allPublicPools.json';\n\n// Replicates SOR Subgraph getAllPublicSwapPools using allPublicPools.json\nexport function getAllPublicSwapPoolsBackup(): any {\n    let poolData = { pools: [] };\n\n    allPools.pools.forEach(p => {\n        if (p.publicSwap && p.finalized) poolData.pools.push(p);\n    });\n\n    return poolData;\n}\n","import fetch from 'isomorphic-fetch';\nconst SUBGRAPH_URL =\n    process.env.REACT_APP_SUBGRAPH_URL ||\n    'https://api.thegraph.com/subgraphs/name/balancer-labs/balancer';\n\n// Returns all public pools\nexport async function getAllPublicSwapPools() {\n    const query = `\n      {\n          pools (first: 1000, where: {publicSwap: true, active: true}) {\n            id\n            swapFee\n            totalWeight\n            publicSwap\n            tokens {\n              id\n              address\n              balance\n              decimals\n              symbol\n              denormWeight\n            }\n            tokensList\n          }\n      }\n    `;\n\n    const response = await fetch(SUBGRAPH_URL, {\n        method: 'POST',\n        headers: {\n            Accept: 'application/json',\n            'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n            query,\n        }),\n    });\n\n    const { data } = await response.json();\n    console.log(`!!!!!! ${data.pools.length}`);\n    return data;\n}\n","import { action, observable } from 'mobx';\nimport RootStore from 'stores/Root';\nimport { EtherKey } from './Token';\nimport { sorTokenPairs } from './Sor';\nimport { supportedChainId } from '../provider/connectors';\nimport { AsyncStatus, TokenPairsFetch } from './actions/fetch';\nimport { getAllPoolDataOnChain } from '@balancer-labs/sor';\nimport { getAllPublicSwapPoolsBackup } from '../utils/poolsBackup';\nimport { BigNumber } from 'utils/bignumber';\nimport { toChecksum, scale, bnum, fromWei } from 'utils/helpers';\nimport { getAllPublicSwapPools } from 'utils/subGraph';\n\nexport type TokenPairs = Set<string>;\n\nexport interface TokenPairData {\n    tokenPairs: TokenPairs;\n    lastFetched: number;\n}\n\nexport interface Pool {\n    id: string;\n    decimalsIn: number;\n    decimalsOut: number;\n    balanceIn: BigNumber;\n    balanceOut: BigNumber;\n    weightIn: BigNumber;\n    weightOut: BigNumber;\n    swapFee: BigNumber;\n}\n\ninterface TokenPairsMap {\n    [index: string]: TokenPairData;\n}\n\nexport default class PoolStore {\n    @observable tokenPairs: TokenPairsMap;\n    @observable onChainPools: any;\n    poolsList: any;\n    onChainPoolsPromise: Promise<void>;\n    rootStore: RootStore;\n\n    constructor(rootStore) {\n        this.rootStore = rootStore;\n        this.tokenPairs = {};\n        this.poolsList = { pools: [] };\n        this.onChainPools = { pools: [] };\n    }\n\n    async loadOnChain() {\n        this.onChainPoolsPromise = this.loadOnChainPools();\n    }\n\n    // TODO: Should this be fetched on a timer to update? See Root.ts for order\n    async loadPoolsList() {\n        if (this.poolsList.pools.length === 0) {\n            console.log(`[Pool] Loading Backup Pools`);\n            this.poolsList = getAllPublicSwapPoolsBackup();\n            this.loadOnChain();\n            console.log(`[Pool] Backup Pools Loaded`);\n        }\n\n        console.log(`[Pool] Loading Subgraph Pools`);\n        //this.poolsList = await getAllPublicSwapPools();\n        getAllPublicSwapPools()\n            .then(response => {\n                if (this.poolsList.pools.length !== response.pools.length) {\n                    console.log(`[Pool] Subgraph Pools Loaded With New Info.`);\n                    this.poolsList = response;\n                } else {\n                    console.log(`[Pool] Subgraph Pools Loaded.`);\n                }\n                // Load on-chain info every time to keep balances fresh\n                this.loadOnChain(); // THIS CAN FREEZE UI??\n            })\n            .catch(err => {\n                console.log(`[Pool] Subgraph Loading Issue. Using Backup.`);\n                console.log(err);\n            });\n    }\n\n    // TODO: Should this be fetched on a timer to update? See Root.ts for order\n    @action private async loadOnChainPools() {\n        try {\n            const {\n                providerStore,\n                contractMetadataStore,\n                sorStore,\n                swapFormStore,\n            } = this.rootStore;\n            const library = providerStore.providerStatus.library;\n            console.log(`[Pool] Loading On-Chain Pool Info...`);\n            await this.onChainPoolsPromise; // Pause if already loading info\n\n            /*\n            REMOVED THIS AS ONLY WANT TO USE ONCHAIN BALANCES FOR EVERYTHING\n            console.log(`[Pool] Fetch paths while waiting for onchain...`);\n            // This function will use Subgraph for paths and wait until on-chain pools are loaded then use those\n            sorStore.fetchPathData(\n                swapFormStore.inputToken.address,\n                swapFormStore.outputToken.address\n            );\n            */\n            console.log(`[Pool] Loading Pool On-chain Balances`);\n            const onChainPoolsFresh = await getAllPoolDataOnChain(\n                this.poolsList,\n                contractMetadataStore.getMultiAddress(),\n                library\n            );\n\n            if (!onChainPoolsFresh) {\n                console.log(`Error loading on-chain, default to Subgraph`);\n                this.onChainPools = this.poolsList;\n            } else this.onChainPools = onChainPoolsFresh;\n\n            sorStore.fetchPathData(\n                swapFormStore.inputToken.address,\n                swapFormStore.outputToken.address\n            );\n\n            this.fetchAndSetTokenPairs(swapFormStore.inputToken.address);\n            this.fetchAndSetTokenPairs(swapFormStore.outputToken.address);\n\n            console.log(`[Pool] All On-chain Pools Loaded`, this.onChainPools);\n        } catch (err) {\n            console.log(err.message);\n            console.log(\n                `[Pool] Issue Loading OnChain pools. Defaulting to Subgraph.`\n            );\n            this.onChainPools = this.poolsList;\n        }\n    }\n\n    @action fetchAndSetTokenPairs(tokenAddress): void {\n        this.fetchTokenPairs(tokenAddress).then(response => {\n            const { status, request, payload } = response;\n            if (status === AsyncStatus.SUCCESS) {\n                this.setTokenPairs(\n                    request.tokenAddress,\n                    payload.tokenPairs,\n                    payload.lastFetched\n                );\n            }\n        });\n    }\n\n    @action async fetchTokenPairs(tokenAddress: string) {\n        const { providerStore, contractMetadataStore } = this.rootStore;\n        const fetchBlock = providerStore.getCurrentBlockNumber();\n\n        //Pre-fetch stale check\n        const stale =\n            fetchBlock <= this.getTokenPairsLastFetched(tokenAddress) &&\n            fetchBlock !== -1;\n\n        if (!stale) {\n            const tokenAddressToFind =\n                tokenAddress === EtherKey\n                    ? contractMetadataStore.getWethAddress()\n                    : tokenAddress;\n\n            // First page load we need to wait for all pools loaded from Subgraph\n            // Subgraph will be loaded quicker than on-chain pools & assume this\n            // data is fine to use for token pairs as no balances required\n            // TO DO: Should we put all pools load on timer loop?\n            console.log(`[Pool] Loading Pairs ${tokenAddressToFind}`);\n            const tokenPairs = await sorTokenPairs(\n                tokenAddressToFind,\n                contractMetadataStore,\n                this.poolsList\n            );\n\n            console.log('[Pool] - TokenPairs Success', {\n                tokenAddress,\n                tokenPairs,\n                fetchBlock,\n            });\n            return new TokenPairsFetch({\n                status: AsyncStatus.SUCCESS,\n                request: {\n                    chainId: supportedChainId,\n                    tokenAddress,\n                    fetchBlock,\n                },\n                payload: {\n                    tokenPairs: tokenPairs,\n                    lastFetched: fetchBlock,\n                },\n            });\n        } else {\n            console.log('[Token Pairs Fetch] - Stale', {\n                tokenAddress,\n                fetchBlock,\n            });\n            return new TokenPairsFetch({\n                status: AsyncStatus.STALE,\n                request: {\n                    chainId: supportedChainId,\n                    tokenAddress,\n                    fetchBlock,\n                },\n                payload: undefined,\n            });\n        }\n    }\n\n    getTokenPairsLastFetched(tokenAddress: string): number {\n        if (this.tokenPairs[tokenAddress]) {\n            return this.tokenPairs[tokenAddress].lastFetched;\n        }\n\n        return -1;\n    }\n\n    getTokenPairs(tokenAddress): TokenPairs | undefined {\n        if (this.tokenPairs[tokenAddress]) {\n            return this.tokenPairs[tokenAddress].tokenPairs;\n        }\n\n        return undefined;\n    }\n\n    @action setTokenPairs(\n        tokenAddress: string,\n        tokenPairs: Set<string>,\n        fetchBlock: number\n    ): void {\n        this.tokenPairs[tokenAddress] = {\n            tokenPairs,\n            lastFetched: fetchBlock,\n        };\n\n        console.log('[setTokenPairs]', {\n            tokenAddress,\n            tokenPairs,\n            fetchBlock,\n            allTokenPairs: { ...this.tokenPairs },\n        });\n    }\n\n    areTokenPairsLoaded(chainId, tokenAddress: string): boolean {\n        this.verifyChainId(chainId);\n\n        console.log('[are token pairs loaded?', {\n            tokenAddress,\n            pairs: this.tokenPairs[tokenAddress],\n        });\n        return !!this.tokenPairs[tokenAddress];\n    }\n\n    isTokenPairTradable(chainId, fromToken: string, toToken: string): boolean {\n        this.verifyChainId(chainId);\n\n        if (!this.areTokenPairsLoaded(chainId, fromToken)) {\n            throw new Error(\n                `Token pair data for ${fromToken} on network ${chainId} not loaded`\n            );\n        }\n\n        return this.tokenPairs[chainId][fromToken].tokenPairs.has(toToken);\n    }\n\n    private verifyChainId(chainId) {\n        if (!this.tokenPairs[chainId]) {\n            throw new Error(\n                'Attempting to access token pairs for non-supported chainId'\n            );\n        }\n    }\n\n    // Finds pools with tokens & loads the balance/weight info for those\n    findPoolTokenInfo = (\n        poolId: string,\n        tokenIn: string,\n        tokenOut: string\n    ): Pool => {\n        // Use Subgraph pools as a backup until on-chain loaded\n        let pool;\n\n        if (this.onChainPools.pools.length === 0) {\n            pool = this.poolsList.pools.find(\n                p => toChecksum(p.id) === toChecksum(poolId)\n            );\n        } else {\n            pool = this.onChainPools.pools.find(\n                p => toChecksum(p.id) === toChecksum(poolId)\n            );\n        }\n\n        if (!pool) {\n            throw new Error(\n                '[Invariant] No pool found for selected balancer index'\n            );\n        }\n\n        let tI: any = pool.tokens.find(\n            t => toChecksum(t.address) === toChecksum(tokenIn)\n        );\n        let tO: any = pool.tokens.find(\n            t => toChecksum(t.address) === toChecksum(tokenOut)\n        );\n\n        let obj: Pool;\n\n        if (tI.balance > 0 && tO.balance > 0) {\n            obj = {\n                id: toChecksum(pool.id),\n                decimalsIn: tI.decimals,\n                decimalsOut: tO.decimals,\n                balanceIn: scale(bnum(tI.balance), tI.decimals),\n                balanceOut: scale(bnum(tO.balance), tO.decimals),\n                weightIn: scale(\n                    bnum(tI.denormWeight).div(bnum(pool.totalWeight)),\n                    18\n                ),\n                weightOut: scale(\n                    bnum(tO.denormWeight).div(bnum(pool.totalWeight)),\n                    18\n                ),\n                swapFee: scale(bnum(pool.swapFee), 18),\n            };\n        }\n\n        console.log(\n            `Pool ${obj.id}, BalIn: ${fromWei(\n                obj.balanceIn\n            )}, WeightIn: ${fromWei(obj.weightIn)}, BalOut: ${fromWei(\n                obj.balanceOut\n            )}, WeightOut: ${fromWei(obj.weightOut)}`\n        );\n        return obj;\n    };\n}\n","import { action, observable } from 'mobx';\nimport { BigNumber } from 'utils/bignumber';\nimport RootStore from 'stores/Root';\n\ninterface Asset {\n    address: string;\n    symbol: string;\n    name: string;\n    hasIcon: boolean;\n    userBalance: string;\n    isTradable: boolean;\n    decimals: number;\n    precision: number;\n    allowance: BigNumber;\n    balanceBn: BigNumber;\n}\n\nexport default class AssetOptions {\n    @observable tokenAssetData: Asset;\n    rootStore: RootStore;\n\n    constructor(rootStore) {\n        this.rootStore = rootStore;\n        this.tokenAssetData = undefined;\n    }\n\n    @action fetchTokenAssetData = async (address: string, account: string) => {\n        console.log(`[AssetOptions] fetchTokenAssetData: ${address}`);\n\n        const { tokenStore } = this.rootStore;\n\n        try {\n            const tokenMetadata = await tokenStore.fetchOnChainTokenMetadata(\n                address,\n                account\n            );\n\n            this.tokenAssetData = {\n                address: tokenMetadata.address,\n                symbol: tokenMetadata.symbol,\n                name: tokenMetadata.name,\n                hasIcon: tokenMetadata.hasIcon,\n                userBalance: tokenMetadata.balanceFormatted,\n                isTradable: true,\n                decimals: tokenMetadata.decimals,\n                precision: tokenMetadata.precision,\n                allowance: tokenMetadata.allowance,\n                balanceBn: tokenMetadata.balanceBn,\n            };\n        } catch (err) {\n            this.tokenAssetData = undefined;\n        }\n    };\n}\n","// Stores\nimport ProxyStore from 'stores/Proxy';\nimport ProviderStore from 'stores/Provider';\nimport BlockchainFetchStore from 'stores/BlockchainFetch';\nimport SwapFormStore from 'stores/SwapForm';\nimport TokenStore from 'stores/Token';\nimport DropdownStore from './Dropdown';\nimport ErrorStore from './Error';\nimport ContractMetadataStore from './ContractMetadata';\nimport TransactionStore from './Transaction';\nimport AppSettingsStore from './AppSettings';\nimport PoolStore from './Pool';\nimport AssetOptionsStore from './AssetOptions';\nimport SorStore from './Sor';\n\nexport default class RootStore {\n    proxyStore: ProxyStore;\n    providerStore: ProviderStore;\n    blockchainFetchStore: BlockchainFetchStore;\n    swapFormStore: SwapFormStore;\n    tokenStore: TokenStore;\n    poolStore: PoolStore;\n    dropdownStore: DropdownStore;\n    contractMetadataStore: ContractMetadataStore;\n    transactionStore: TransactionStore;\n    appSettingsStore: AppSettingsStore;\n    assetOptionsStore: AssetOptionsStore;\n    sorStore: SorStore;\n    errorStore: ErrorStore;\n\n    constructor() {\n        this.proxyStore = new ProxyStore(this);\n        this.poolStore = new PoolStore(this);\n        this.providerStore = new ProviderStore(this);\n        this.blockchainFetchStore = new BlockchainFetchStore(this);\n        this.contractMetadataStore = new ContractMetadataStore(this);\n        this.swapFormStore = new SwapFormStore(this);\n        this.tokenStore = new TokenStore(this);\n        this.dropdownStore = new DropdownStore(this);\n        this.transactionStore = new TransactionStore(this);\n        this.appSettingsStore = new AppSettingsStore(this);\n        this.assetOptionsStore = new AssetOptionsStore(this);\n        this.sorStore = new SorStore(this);\n        this.errorStore = new ErrorStore(this);\n\n        this.asyncSetup().catch(e => {\n            //TODO: Add retry on these fetches\n            throw new Error('Async Setup Failed ' + e);\n        });\n    }\n\n    async asyncSetup() {\n        await this.providerStore.loadWeb3();\n        this.swapFormStore.setDefaultTokenAddresses(\n            this.providerStore.providerStatus.account\n        );\n        this.poolStore.loadPoolsList();\n        this.blockchainFetchStore.blockchainFetch(false);\n        // Load on-chain data as soon as a provider is available\n    }\n}\n","// src/contexts/index.tsx\nimport React from 'react';\nimport RootStore from 'stores/Root';\n\nexport const storesContext = React.createContext({\n    root: new RootStore(),\n});\n\nexport const useStores = () => React.useContext(storesContext);\n","import { useCallback, useEffect, useRef, useState } from 'react';\nimport copy from 'copy-to-clipboard';\n\nexport function useInterval(callback, delay) {\n    const savedCallback = useRef();\n\n    // Remember the latest function.\n    useEffect(() => {\n        savedCallback.current = callback;\n    }, [callback]);\n\n    // Set up the interval.\n    useEffect(() => {\n        function tick() {\n            savedCallback.current();\n        }\n        if (delay !== null) {\n            let id = setInterval(tick, delay);\n            return () => clearInterval(id);\n        }\n    }, [delay]);\n}\n\nexport function useCopyClipboard(timeout = 500) {\n    const [isCopied, setIsCopied] = useState(false);\n\n    const staticCopy = useCallback(text => {\n        const didCopy = copy(text);\n        setIsCopied(didCopy);\n    }, []);\n\n    useEffect(() => {\n        if (isCopied) {\n            const hide = setTimeout(() => {\n                setIsCopied(false);\n            }, timeout);\n\n            return () => {\n                clearTimeout(hide);\n            };\n        }\n    }, [isCopied, setIsCopied, timeout]);\n\n    return [isCopied, staticCopy];\n}\n\n// modified from https://usehooks.com/usePrevious/\nexport function usePrevious(value) {\n    // The ref object is a generic container whose current property is mutable ...\n    // ... and can hold any value, similar to an instance property on a class\n    const ref = useRef();\n\n    // Store current value in ref\n    useEffect(() => {\n        ref.current = value;\n    }, [value]); // Only re-run if value changes\n\n    // Return previous value (happens before update in useEffect above)\n    return ref.current;\n}\n","import React, { useEffect, useState } from 'react';\nimport styled, { keyframes } from 'styled-components';\nimport { useStores } from 'contexts/storesContext';\nimport { useInterval } from 'utils/helperHooks';\nimport { observer } from 'mobx-react';\n\nimport Circle from '../../assets/images/circle.svg';\n// /* eslint import/no-webpack-loader-syntax: off */\n// import Worker from 'worker-loader!../../utils/sgWebWorker.js';\n\nconst MessageWrapper = styled.div`\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    height: calc(100vh);\n    background-color: var(--panel-background);\n`;\n\nconst rotate = keyframes`\n  from {\n    transform: rotate(0deg);\n  }\n  to {\n    transform: rotate(360deg);\n  }\n`;\n\nconst Spinner = styled.img`\n    animation: 2s ${rotate} linear infinite;\n    width: 16px;\n    height: 16px;\n`;\n\nconst Web3Manager = observer(({ children }) => {\n    const {\n        root: { providerStore, blockchainFetchStore, poolStore },\n    } = useStores();\n\n    // handle delayed loader state\n    const [showLoader, setShowLoader] = useState(true);\n\n    /*\n    const tWorker = new Worker('utils/sgWebWorker.js');\n    tWorker.postMessage(JSON.stringify(poolStore.subgraphPools));\n\n    useEffect(() => {\n        tWorker.onmessage = ev => {\n            console.log(`@@@@@@ Event received!!!`);\n        };\n    }, [tWorker]);\n    */\n\n    useEffect(() => {\n        const timeout = setTimeout(() => {\n            setShowLoader(true);\n        }, 600);\n\n        return () => {\n            clearTimeout(timeout);\n        };\n    }, []);\n\n    //Fetch user blockchain data on an interval using current params\n    blockchainFetchStore.blockchainFetch(false);\n    useInterval(() => blockchainFetchStore.blockchainFetch(false), 2000);\n    useInterval(() => poolStore.loadPoolsList(), 120000);\n\n    // This means no injected web3 and infura backup has failed\n    if (!providerStore.providerStatus.active) {\n        return showLoader ? (\n            <MessageWrapper>\n                <Spinner src={Circle} />\n            </MessageWrapper>\n        ) : null;\n    }\n\n    return children;\n});\n\nexport default Web3Manager;\n","import React from 'react';\nimport styled, { keyframes } from 'styled-components';\nimport { Check } from 'react-feather';\nimport { getEtherscanLink } from 'utils/helpers';\nimport Circle from '../../assets/images/circle.svg';\nimport { useStores } from '../../contexts/storesContext';\n\nconst TransactionStatusWrapper = styled.div`\n    display: flex;\n    align-items: center;\n    min-width: 12px;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n    a {\n        color: var(--link-text);\n        font-weight: 500;\n        font-size: 14px;\n    }\n`;\n\nconst TransactionWrapper = styled.div`\n    display: flex;\n    flex-flow: row nowrap;\n    justify-content: space-between;\n    width: 100%;\n    margin-top: 0.75rem;\n    a {\n        /* flex: 1 1 auto; */\n        overflow: hidden;\n        text-overflow: ellipsis;\n        white-space: nowrap;\n        min-width: 0;\n        max-width: 250px;\n    }\n`;\n\nconst rotate = keyframes`\n  from {\n    transform: rotate(0deg);\n  }\n  to {\n    transform: rotate(360deg);\n  }\n`;\n\nconst Spinner = styled.img`\n    animation: 2s ${rotate} linear infinite;\n    width: 16px;\n    height: 16px;\n`;\n\nconst TransactionState = styled.div`\n    display: flex;\n    color: ${({ pending, theme }) => (pending ? '#DC6BE5' : '#27AE60')};\n    padding: 0.5rem 0.75rem;\n    font-weight: 500;\n    font-size: 0.75rem;\n    #pending {\n        animation: 2s ${rotate} linear infinite;\n    }\n`;\n\nexport default function Transaction({ hash, pending }) {\n    const {\n        root: { providerStore },\n    } = useStores();\n\n    const chainId = providerStore.providerStatus.chainId;\n\n    return (\n        <TransactionWrapper key={hash}>\n            {pending ? (\n                <TransactionState pending={pending}>\n                    <Spinner src={Circle} id=\"pending\" />\n                </TransactionState>\n            ) : (\n                <TransactionState pending={pending}>\n                    <Check size=\"16\" />\n                </TransactionState>\n            )}\n            <TransactionStatusWrapper>\n                <a\n                    href={getEtherscanLink(chainId, hash, 'transaction')}\n                    target=\"_blank\"\n                    rel=\"noopener noreferrer\"\n                >\n                    {hash} {' '}\n                </a>\n            </TransactionStatusWrapper>\n        </TransactionWrapper>\n    );\n}\n","import React from 'react';\nimport styled from 'styled-components';\nimport { observer } from 'mobx-react';\nimport { useStores } from 'contexts/storesContext';\nimport Transaction from './Transaction';\nimport { TransactionRecord } from 'stores/Transaction';\nimport { isChainIdSupported } from '../../provider/connectors';\n\nconst TransactionListWrapper = styled.div`\n    display: flex;\n    flex-flow: column nowrap;\n`;\n\nconst Panel = styled.div`\n    text-align: left;\n    display: flex;\n    flex-flow: column nowrap;\n    padding-top: 2rem;\n    flex-grow: 1;\n    overflow: auto;\n    background-color: var(--panel-background);\n`;\n\nconst TransactionHeader = styled.div`\n    border-top: 1px solid var(--panel-border);\n    align-items: left;\n    font-family: Roboto;\n    font-style: normal;\n    font-weight: 500;\n    font-size: 14px;\n    line-height: 18px;\n    padding-top: 14px;\n    color: var(--token-balance-text);\n    text-transform: uppercase;\n`;\n\nconst TransactionPanel = observer(() => {\n    const {\n        root: { transactionStore, providerStore },\n    } = useStores();\n\n    const account = providerStore.providerStatus.account;\n    const activeChainId = providerStore.providerStatus.activeChainId;\n\n    let pending = undefined;\n    let confirmed = undefined;\n\n    if (account && isChainIdSupported(activeChainId)) {\n        pending = transactionStore.getPendingTransactions(account);\n        confirmed = transactionStore.getConfirmedTransactions(account);\n    }\n\n    function renderTransactions(transactions: TransactionRecord[], pending) {\n        return (\n            <TransactionListWrapper>\n                {transactions.map((value, i) => {\n                    return (\n                        <Transaction\n                            key={i}\n                            hash={value.hash}\n                            pending={pending}\n                        />\n                    );\n                })}\n            </TransactionListWrapper>\n        );\n    }\n\n    let hasTx = !!pending.length || !!confirmed.length;\n\n    if (hasTx) {\n        return (\n            <Panel>\n                <TransactionHeader>Recent Transactions</TransactionHeader>\n                {renderTransactions(pending, true)}\n                {renderTransactions(confirmed, false)}\n            </Panel>\n        );\n    }\n\n    return <></>;\n});\n\nexport default TransactionPanel;\n","import React, { useEffect, useState, useRef } from 'react';\nimport styled from 'styled-components';\nimport { observer } from 'mobx-react';\nimport { web3Window as window } from 'provider/Web3Window';\nimport { usePrevious } from 'utils/helperHooks';\nimport { useStores } from 'contexts/storesContext';\nimport TransactionPanel from './TransactionPanel';\n\nconst StyledLink = styled.a`\n    color: #ffffff;\n    cursor: pointer;\n`;\n\nconst Lightbox = styled.div`\n    text-align: center;\n    position: fixed;\n    width: 100vw;\n    height: 100vh;\n    margin-left: -50vw;\n    top: 78px;\n    pointer-events: none;\n    left: 50%;\n    z-index: 2;\n    will-change: opacity;\n    background-color: rgba(0, 0, 0, 0.4);\n`;\n\nconst Wrapper = styled.div`\n    background-color: var(--panel-background);\n    position: absolute;\n    top: 0px;\n    right: 25px;\n    padding: 20px;\n    transition: all 0.5s ease;\n    margin: 0;\n    width: 300px;\n    pointer-events: auto;\n    z-index: 100;\n    border: 1px solid var(--panel-border);\n    border-radius: 0 0 4px 4px;\n`;\n\nconst WALLET_VIEWS = {\n    OPTIONS: 'options',\n    OPTIONS_SECONDARY: 'options_secondary',\n    ACCOUNT: 'account',\n    PENDING: 'pending',\n};\n\nfunction useOnClickOutside(ref, handler) {\n    useEffect(() => {\n        const handleClick = event => {\n            // Do nothing if clicking ref's element or descendent elements\n            if (!ref.current || ref.current.contains(event.target)) {\n                return;\n            }\n\n            handler(event);\n        };\n\n        const handleKeyUp = event => {\n            if (event.key !== 'Escape') {\n                return;\n            }\n            handler(event);\n        };\n\n        document.addEventListener('mousedown', handleClick);\n        window.addEventListener('keydown', handleKeyUp, false);\n        document.addEventListener('touchstart', handleClick);\n\n        return () => {\n            document.removeEventListener('mousedown', handleClick);\n            window.removeEventListener('keydown', handleKeyUp, false);\n            document.removeEventListener('touchstart', handleClick);\n        };\n    }, [ref, handler]);\n}\n\nconst WalletDropdown = observer(() => {\n    const {\n        root: { dropdownStore, providerStore },\n    } = useStores();\n\n    const active = providerStore.providerStatus.active;\n    const error = providerStore.providerStatus.error;\n    const account = providerStore.providerStatus.account;\n    const injectedActive = providerStore.providerStatus.injectedActive;\n    const [walletView, setWalletView] = useState(WALLET_VIEWS.ACCOUNT);\n\n    const walletDropdownOpen = dropdownStore.walletDropdownVisible;\n\n    const toggleWalletDropdown = () => {\n        dropdownStore.toggleWalletDropdown();\n    };\n\n    // always reset to account view\n    useEffect(() => {\n        if (walletDropdownOpen) {\n            setWalletView(WALLET_VIEWS.ACCOUNT);\n        }\n    }, [walletDropdownOpen]);\n\n    const ref = useRef();\n    useOnClickOutside(ref, () => dropdownStore.toggleWalletDropdown());\n\n    // close modal when a connection is successful\n    const activePrevious = usePrevious(active);\n    useEffect(() => {\n        if (walletDropdownOpen && active && !activePrevious) {\n            setWalletView(WALLET_VIEWS.ACCOUNT);\n        }\n    }, [setWalletView, active, error, walletDropdownOpen, activePrevious]);\n\n    async function loadWalletDropdown() {\n        if (walletDropdownOpen) {\n            toggleWalletDropdown();\n        }\n        setWalletView(WALLET_VIEWS.ACCOUNT);\n        await providerStore.loadWeb3Modal();\n    }\n\n    function getDropdownContent() {\n        if (account && injectedActive && walletView === WALLET_VIEWS.ACCOUNT) {\n            return (\n                <>\n                    <>\n                        {(window.web3 || window.ethereum) && (\n                            <StyledLink\n                                onClick={() => {\n                                    setWalletView(WALLET_VIEWS.OPTIONS);\n                                }}\n                            >\n                                Connect to a different wallet\n                            </StyledLink>\n                        )}\n                    </>\n                    <TransactionPanel />\n                </>\n            );\n        }\n\n        if (walletDropdownOpen) {\n            loadWalletDropdown();\n        }\n        return null;\n    }\n\n    if (walletDropdownOpen) {\n        return (\n            <Lightbox>\n                <Wrapper ref={ref}>{getDropdownContent()}</Wrapper>\n            </Lightbox>\n        );\n    }\n});\n\nexport default WalletDropdown;\n","import React, { useEffect, useRef } from 'react';\n\nimport styled from 'styled-components';\n\nimport Jazzicon from 'jazzicon';\nimport { useStores } from '../../contexts/storesContext';\n\nconst StyledIdenticon = styled.div`\n    height: 1rem;\n    width: 1rem;\n    border-radius: 1.125rem;\n    background-color: ${({ theme }) => theme.silverGray};\n`;\n\nexport default function Identicon() {\n    const ref = useRef();\n\n    const {\n        root: { providerStore },\n    } = useStores();\n    const account = providerStore.providerStatus.account;\n\n    useEffect(() => {\n        if (account && ref.current) {\n            ref.current.innerHTML = '';\n            ref.current.appendChild(\n                Jazzicon(16, parseInt(account.slice(2, 10), 16))\n            );\n        }\n    });\n\n    return <StyledIdenticon ref={ref} />;\n}\n","import React from 'react';\nimport styled from 'styled-components';\n\nconst Container = styled.div`\n    font-family: var(--roboto);\n    display: flex;\n    flex-direction: row;\n    align-items: center;\n    justify-content: center;\n`;\n\nconst ButtonBase = styled.div`\n    border-radius: 4px;\n    width: 163px;\n    height: 40px;\n\n    font-family: var(--roboto);\n    font-style: normal;\n    font-weight: 500;\n    font-size: 14px;\n    line-height: 16px;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    text-align: center;\n    cursor: pointer;\n`;\n\nconst ActiveButton = styled(ButtonBase)`\n    background: var(--button-background);\n    border: 1px solid var(--button-border);\n    color: var(--button-text);\n`;\n\nconst InactiveButton = styled(ButtonBase)`\n    background: var(--background);\n    border: 1px solid var(--inactive-button-border);\n    color: var(--inactive-button-text);\n`;\n\nconst Button = ({ buttonText, active, onClick }) => {\n    const ButtonDisplay = ({ activeButton, children }) => {\n        if (activeButton) {\n            return <ActiveButton onClick={onClick}>{children}</ActiveButton>;\n        } else {\n            return <InactiveButton>{children}</InactiveButton>;\n        }\n    };\n\n    return (\n        <Container>\n            <ButtonDisplay activeButton={active}>{buttonText}</ButtonDisplay>\n        </Container>\n    );\n};\n\nexport default Button;\n","import React from 'react';\nimport styled, { keyframes } from 'styled-components';\nimport { Activity } from 'react-feather';\nimport { observer } from 'mobx-react';\nimport { shortenAddress } from 'utils/helpers';\nimport WalletDropdown from 'components/WalletDropdown';\nimport Circle from 'assets/images/circle.svg';\nimport Identicon from '../Identicon';\nimport { useStores } from '../../contexts/storesContext';\n\nimport Dropdown from '../../assets/images/dropdown.svg';\nimport Dropup from '../../assets/images/dropup.svg';\n\nimport Button from '../Button';\n\nconst WarningIcon = styled.img`\n    width: 22px;\n    height: 26px;\n    margin-right: 0px;\n    color: var(--warning);\n`;\n\nconst rotate = keyframes`\n  from {\n    transform: rotate(0deg);\n  }\n  to {\n    transform: rotate(360deg);\n  }\n`;\n\nconst Spinner = styled.img`\n    animation: 2s ${rotate} linear infinite;\n    width: 16px;\n    height: 16px;\n`;\n\nconst Address = styled.div`\n    color: var(--address-color);\n`;\n\nconst WalletButton = styled.button`\n    background-color: var(--panel);\n    display: flex;\n    flex-flow: row nowrap;\n    border-radius: 4px;\n    padding: 0.5rem;\n    border: 1px solid var(--panel-border);\n    font-weight: 500;\n    font-size: 14px;\n    line-height: 16px;\n    cursor: pointer;\n    justify-content: space-evenly;\n    align-items: center;\n    text-align: center;\n    height: 40px;\n    width: 160px;\n    :focus {\n        outline: none;\n    }\n`;\n\nconst Error = styled.button`\n    background-color: var(--panel);\n    border: 1px solid var(--warning);\n    display: flex;\n    flex-flow: row nowrap;\n    font-size: 0.9rem;\n    align-items: center;\n    padding: 0.5rem;\n    border-radius: 4px;\n    box-sizing: border-box;\n    cursor: pointer;\n    user-select: none;\n    :focus {\n        outline: none;\n    }\n    color: #ffffff;\n    font-weight: 500;\n`;\n\nconst ErrorMessage = styled.span`\n    margin: 0 0.5rem 0 0.25rem;\n    font-size: 0.83rem;\n`;\n\nconst NetworkIcon = styled(Activity)`\n    margin-left: 0.25rem;\n    margin-right: 0.5rem;\n    width: 16px;\n    height: 16px;\n`;\n\nconst SpinnerWrapper = styled(Spinner)`\n    margin: 0 0.25rem 0 0.25rem;\n`;\n\nconst Wallet = observer(() => {\n    const {\n        root: { dropdownStore, transactionStore, providerStore },\n    } = useStores();\n\n    const account = providerStore.providerStatus.account;\n    const activeChainId = providerStore.providerStatus.activeChainId;\n    const active = providerStore.providerStatus.active;\n    const error = providerStore.providerStatus.error;\n    const injectedActive = providerStore.providerStatus.injectedActive;\n    const injectedLoaded = providerStore.providerStatus.injectedLoaded;\n\n    if (!activeChainId && active) {\n        throw new Error(`No chain ID specified ${activeChainId}`);\n    }\n\n    let hasPendingTransactions = transactionStore.hasPendingTransactions(\n        account\n    );\n\n    const toggleWalletDropdown = async () => {\n        dropdownStore.toggleWalletDropdown();\n    };\n\n    // handle the logo we want to show with the account\n    function getStatusIcon() {\n        if (injectedActive) {\n            return <Identicon />;\n        }\n    }\n\n    function getWalletDetails() {\n        // Wrong network\n        if (injectedLoaded && !injectedActive) {\n            return (\n                <Error onClick={toggleWalletDropdown}>\n                    <WarningIcon src=\"WarningSign.svg\" />\n                    <ErrorMessage>Wrong Network</ErrorMessage>\n                </Error>\n            );\n        } else if (account) {\n            return (\n                <WalletButton onClick={toggleWalletDropdown}>\n                    {hasPendingTransactions && (\n                        <SpinnerWrapper src={Circle} alt=\"loader\" />\n                    )}\n                    {getStatusIcon()}\n                    <Address>{shortenAddress(account)}</Address>\n                    {dropdownStore.walletDropdownVisible ? (\n                        <img src={Dropup} alt=\"v\" />\n                    ) : (\n                        <img src={Dropdown} alt=\"^\" />\n                    )}\n                </WalletButton>\n            );\n        } else if (error) {\n            return (\n                <Error onClick={toggleWalletDropdown}>\n                    <NetworkIcon />\n                    <ErrorMessage>Error</ErrorMessage>\n                </Error>\n            );\n        } else {\n            return (\n                <Button\n                    onClick={toggleWalletDropdown}\n                    buttonText=\"Connect Wallet\"\n                    active={true}\n                />\n            );\n        }\n    }\n\n    return (\n        <>\n            {getWalletDetails()}\n            <WalletDropdown />\n        </>\n    );\n});\n\nexport default Wallet;\n","//@ts-ignore\nimport React from 'react';\nimport { appConfig } from 'configs';\nimport styled from 'styled-components';\nimport Wallet from '../Wallet';\n\nconst HeaderFrame = styled.div`\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    width: 100%;\n`;\n\nconst HeaderElement = styled.div`\n    margin: 1.25rem;\n    display: flex;\n    min-width: 0;\n    display: flex;\n    align-items: center;\n`;\n\nconst Title = styled.div`\n    display: flex;\n    align-items: center;\n    cursor: pointer;\n    a {\n        display: inline;\n        font-size: 1rem;\n        font-weight: 500;\n        text-decoration: none;\n        img {\n            height: 32px;\n            width: 32px;\n        }\n    }\n`;\n\nconst AppName = styled.div`\n    font-family: Roboto;\n    font-style: normal;\n    font-weight: 500;\n    font-size: 15px;\n    line-height: 18px;\n    letter-spacing: 1px;\n    color: var(--header-text);\n    margin-left: 12px;\n`;\n\nconst Link = styled.a`\n    font-family: Roboto;\n    margin-right: 24px;\n    font-size: 15px;\n    display: flex;\n    align-items: center;\n    color: var(--header-text);\n    text-decoration: none;\n    @media screen and (max-width: 767px) {\n        display: none;\n    }\n`;\n\nconst Header = () => {\n    return (\n        <HeaderFrame>\n            <HeaderElement>\n                <Title>\n                    <a href=\"/\">\n                        <img src=\"pebbles-pad.svg\" alt=\"pebbles\" />\n                    </a>\n                    <AppName>{appConfig.name}</AppName>\n                </Title>\n            </HeaderElement>\n            <HeaderElement>\n                <Link href=\"https://nobsu.github.io/balancer-pool.github.io\" target=\"_blank\">\n                    Add Liquidity\n                </Link>\n                <Wallet />\n            </HeaderElement>\n        </HeaderFrame>\n    );\n};\n\nexport default Header;\n","import React from 'react';\nimport styled from 'styled-components';\n\nconst Wrapper = styled.div``;\n\nconst Warning = styled.div`\n    display: flex;\n    flex-direction: row;\n    align-items: center;\n    color: var(--info);\n    width: 50%;\n    margin: 20px auto;\n    border: 1px solid var(--info);\n    border-radius: 4px;\n    padding: 20px;\n    @media screen and (max-width: 1024px) {\n        width: 80%;\n    }\n`;\n\nconst Message = styled.div`\n    display: inline;\n    font-family: Roboto;\n    font-style: normal;\n    font-weight: normal;\n    font-size: 14px;\n    line-height: 16px;\n    letter-spacing: 0.2px;\n`;\n\nconst WarningIcon = styled.img`\n    width: 22px;\n    height: 26px;\n    margin-right: 20px;\n    color: var(--info);\n`;\n\nconst Link = styled.a`\n    color: color: var(--info);\n`;\n\nconst GeneralNotification = () => {\n    return (\n        <Wrapper>\n            <Warning>\n                <WarningIcon src=\"info-general-notification.svg\" />\n                <Message>\n                    The exchange has been upgraded to use multi-path order\n                    routing which improves overall pricing and gas usage. You\n                    will need to unlock tokens again for the new{' '}\n                    <Link\n                        href=\"https://etherscan.io/address/0x3E66B66Fd1d0b02fDa6C811Da9E0547970DB2f21\"\n                        target=\"_blank\"\n                        rel=\"noopener noreferrer\"\n                    >\n                        proxy contract\n                    </Link>\n                    . To use the old exchange proxy visit:{' '}\n                    <Link\n                        href=\"https://legacy.balancer.exchange\"\n                        target=\"_blank\"\n                        rel=\"noopener noreferrer\"\n                    >\n                        https://legacy.balancer.exchange\n                    </Link>\n                </Message>\n            </Warning>\n        </Wrapper>\n    );\n};\n\nexport default GeneralNotification;\n","import React from 'react';\nimport styled from 'styled-components';\nimport { isAddress } from '../utils/helpers';\nimport { EtherKey } from '../stores/Token';\nimport { ModalType } from '../stores/SwapForm';\nimport { observer } from 'mobx-react';\nimport { useStores } from '../contexts/storesContext';\n\nconst Panel = styled.div`\n    width: 180px;\n    height: 203px;\n    background-color: var(--panel-background);\n    border: 1px solid var(--panel-border);\n    border-radius: 4px;\n`;\n\nconst PanelHeader = styled.div`\n    height: 48px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    font-family: Roboto;\n    font-style: normal;\n    font-weight: 500;\n    font-size: 14px;\n    line-height: 16px;\n    color: var(--header-text);\n    background-color: var(--panel-header-background);\n    border-radius: 4px;\n`;\n\nconst TokenContainer = styled.div`\n    height: 94px;\n    color: var(--header-text);\n    border-top: 1px solid var(--panel-border);\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    cursor: pointer;\n    :hover {\n        background-color: var(--panel-hover-background);\n        border: 1px solid var(--panel-hover-border);\n        margin-left: -1px;\n        margin-right: -1px;\n        margin-bottom: -1px;\n    }\n`;\n\nconst IconAndNameContainer = styled.div`\n    display: flex;\n    flex-direction: row;\n`;\n\nexport const TokenIconAddress = (address, hasIcon) => {\n    if (address === 'ether') {\n        return `https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/info/logo.png`;\n    } else if (!hasIcon) {\n        return './empty-token.png';\n    } else {\n        return `https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/${isAddress(\n            address\n        )}/logo.png`;\n    }\n};\n\nconst TokenIcon = styled.img`\n    width: 28px;\n    height: 28px;\n    margin-right: 12px;\n`;\n\nconst TokenName = styled.div`\n    font-family: Roboto;\n    font-style: normal;\n    font-weight: normal;\n    font-size: 16px;\n    line-height: 19px;\n    display: flex;\n    align-items: center;\n`;\n\nconst TokenBalance = styled.div`\n    font-family: Roboto;\n    font-style: normal;\n    font-weight: normal;\n    font-size: 14px;\n    line-height: 16px;\n    display: flex;\n    align-items: center;\n    text-align: center;\n    color: var(--body-text);\n    margin-top: 12px;\n`;\n\nconst InputWrapper = styled.div`\n    height: 60px;\n    font-family: Roboto;\n    font-style: normal;\n    font-weight: 500;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    padding-left: 21px;\n    padding-right: 21px;\n    border-top: 1px solid var(--panel-border);\n    border-radius: 0px 0px 4px 4px;\n    input {\n        width: 100px;\n        color: var(--input-text);\n        font-size: 16px;\n        font-weight: 500;\n        line-height: 19px;\n        background-color: var(--panel-background);\n        border: none;\n        box-shadow: inset 0 0 0 1px var(--panel-background),\n            inset 0 0 0 100px var(--panel-background);\n        :-webkit-autofill,\n        :-webkit-autofill:hover,\n        :-webkit-autofill:focus,\n        :-webkit-autofill:active,\n        :-internal-autofill-selected {\n            -webkit-text-fill-color: var(--body-text);\n        }\n        ::placeholder {\n            color: var(--input-placeholder-text);\n        }\n        :focus {\n            outline: none;\n        }\n    }\n    border: ${props =>\n        props.errorBorders ? '1px solid var(--error-color)' : ''};\n    margin-left: ${props => (props.errorBorders ? '-1px' : '0px')}\n    margin-right: ${props => (props.errorBorders ? '-1px' : '0px')}\n    :hover {\n        background-color: var(--input-hover-background);\n        border: ${props =>\n            props.errorBorders\n                ? '1px solid var(--error-color)'\n                : '1px solid var(--input-hover-border);'};\n        margin-left: -1px;\n        margin-right: -1px;\n        input {\n            background-color: var(--input-hover-background);\n            box-shadow: inset 0 0 0 1px var(--input-hover-background),\n                inset 0 0 0 100px var(--input-hover-background);\n            ::placeholder {\n                color: var(--input-hover-placeholder-text);\n                background-color: var(--input-hover-background);\n            }\n        }\n    }\n`;\n\nconst MaxLink = styled.div`\n    font-weight: 500;\n    font-size: 14px;\n    line-height: 16px;\n    display: flex;\n    text-decoration-line: underline;\n    color: var(--link-text);\n    cursor: pointer;\n`;\n\nconst Token = observer(\n    ({\n        value,\n        onChange,\n        updateSwapFormData,\n        inputID,\n        inputName,\n        headerText,\n        tokenSymbol,\n        tokenName,\n        tokenBalance,\n        truncatedTokenBalance,\n        tokenAddress,\n        tokenHasIcon,\n        errorMessage,\n        showMax,\n    }) => {\n        const {\n            root: { swapFormStore },\n        } = useStores();\n\n        const IconError = e => {\n            e.target.src = './empty-token.png';\n        };\n\n        const modalType =\n            inputName === 'inputAmount' ? ModalType.INPUT : ModalType.OUTPUT;\n\n        return (\n            <Panel>\n                <PanelHeader>{headerText}</PanelHeader>\n                <TokenContainer\n                    onClick={() => {\n                        swapFormStore.setAssetModalState({\n                            open: true,\n                            input: inputName,\n                        });\n                    }}\n                >\n                    <IconAndNameContainer>\n                        <TokenIcon\n                            src={TokenIconAddress(tokenAddress, tokenHasIcon)}\n                            onError={e => {\n                                IconError(e);\n                            }}\n                        />\n                        <TokenName>{tokenSymbol}</TokenName>\n                    </IconAndNameContainer>\n                    <TokenBalance>\n                        {truncatedTokenBalance} {tokenSymbol}\n                    </TokenBalance>\n                </TokenContainer>\n                <InputWrapper errorBorders={errorMessage !== ''}>\n                    <input value={value} onChange={onChange} placeholder=\"0\" />\n                    {(tokenAddress === EtherKey &&\n                        modalType === ModalType.INPUT) ||\n                    !showMax ? (\n                        <div />\n                    ) : (\n                        <MaxLink\n                            onClick={() => updateSwapFormData(tokenBalance)}\n                        >\n                            Max\n                        </MaxLink>\n                    )}\n                </InputWrapper>\n            </Panel>\n        );\n    }\n);\n\nexport default Token;\n","import React from 'react';\nimport TokenPanel from './TokenPanel';\nimport { observer } from 'mobx-react';\nimport { useStores } from '../contexts/storesContext';\n\nconst BuyToken = observer(\n    ({\n        inputName,\n        tokenSymbol,\n        tokenName,\n        tokenBalance,\n        truncatedTokenBalance,\n        tokenAddress,\n        tokenHasIcon,\n        errorMessage,\n        showMax,\n    }) => {\n        const {\n            root: { swapFormStore },\n        } = useStores();\n\n        const onChange = async event => {\n            const { value } = event.target;\n            updateSwapFormData(value);\n        };\n\n        /* To protect against race conditions in this async method we check\n        for staleness of inputAmount after getting preview and before making updates */\n        const updateSwapFormData = async value => {\n            await swapFormStore.refreshSwapFormPreviewEAO(value);\n        };\n\n        const { inputs } = swapFormStore;\n        const { outputAmount } = inputs;\n\n        return (\n            <TokenPanel\n                headerText=\"Token to Buy\"\n                value={outputAmount}\n                onChange={e => onChange(e)}\n                updateSwapFormData={updateSwapFormData}\n                inputName={inputName}\n                tokenSymbol={tokenSymbol}\n                tokenName={tokenName}\n                tokenBalance={tokenBalance}\n                truncatedTokenBalance={truncatedTokenBalance}\n                tokenAddress={tokenAddress}\n                tokenHasIcon={tokenHasIcon}\n                errorMessage={errorMessage}\n                showMax={false}\n            />\n        );\n    }\n);\n\nexport default BuyToken;\n","import React from 'react';\nimport TokenPanel from './TokenPanel';\nimport { observer } from 'mobx-react';\nimport { useStores } from '../contexts/storesContext';\n\nconst SellToken = observer(\n    ({\n        inputName,\n        tokenSymbol,\n        tokenName,\n        tokenBalance,\n        truncatedTokenBalance,\n        tokenAddress,\n        tokenHasIcon,\n        errorMessage,\n        showMax,\n    }) => {\n        const {\n            root: { swapFormStore },\n        } = useStores();\n\n        const onChange = async event => {\n            const { value } = event.target;\n            updateSwapFormData(value);\n        };\n\n        /* To protect against race conditions in this async method we check\n        for staleness of inputAmount after getting preview and before making updates */\n        const updateSwapFormData = async value => {\n            await swapFormStore.refreshSwapFormPreviewEAI(value);\n        };\n\n        const { inputs } = swapFormStore;\n        const { inputAmount } = inputs;\n\n        return (\n            <TokenPanel\n                headerText=\"Token to Sell\"\n                value={inputAmount}\n                onChange={e => onChange(e)}\n                updateSwapFormData={updateSwapFormData}\n                inputName={inputName}\n                tokenSymbol={tokenSymbol}\n                tokenName={tokenName}\n                tokenBalance={tokenBalance}\n                truncatedTokenBalance={truncatedTokenBalance}\n                tokenAddress={tokenAddress}\n                tokenHasIcon={tokenHasIcon}\n                errorMessage={errorMessage}\n                showMax={showMax}\n            />\n        );\n    }\n);\n\nexport default SellToken;\n","import React from 'react';\nimport { observer } from 'mobx-react';\nimport styled, { keyframes } from 'styled-components';\nimport { useStores } from '../contexts/storesContext';\n\nconst Container = styled.div`\n\tdisplay: flex;\n\tjustify-content: center;\n\talign-items: center\n\twidth: 148px;\n`;\n\nconst SwapIcon = styled.img`\n    width: 24px;\n    height: 24px;\n    cursor: pointer;\n`;\n\nconst rotate = keyframes`\n  from {\n    transform: rotate(0deg);\n  }\n  to {\n    transform: rotate(360deg);\n  }\n`;\n\nconst Spinner = styled.img`\n    animation: 2s ${rotate} linear infinite;\n    width: 80px;\n    height: 80px;\n`;\n\nconst Switch = observer(() => {\n    const {\n        root: { swapFormStore },\n    } = useStores();\n\n    const switchAssets = () => {\n        swapFormStore.switchInputOutputValues();\n    };\n\n    const showLoader = swapFormStore.showLoader;\n\n    return (\n        <Container>\n            <Spinner\n                src=\"/balancer.github.io/circle.svg\"\n                style={{ display: showLoader ? 'block' : 'none' }}\n            />\n            <SwapIcon\n                src=\"/balancer.github.io/swap.svg\"\n                onClick={() => switchAssets()}\n                style={{ display: showLoader ? 'none' : 'block' }}\n            />\n        </Container>\n    );\n});\n\nexport default Switch;\n","import React from 'react';\nimport styled from 'styled-components';\n\nconst ErrorTextContainer = styled.div`\n    font-family: var(--roboto);\n    font-size: 14px;\n    line-height: 16px;\n    display: flex;\n    align-items: center;\n    text-align: center;\n    color: var(--error-color);\n    margin-top: 6px;\n    margin-bottom: 36px;\n`;\n\nconst ErrorTextContainerPlaceholder = styled.div`\n    height: 58px;\n`;\n\nconst ErrorDisplay = ({ errorText }) => {\n    const ErrorTextElement = ({ errorText }) => {\n        if (errorText) {\n            return <ErrorTextContainer>{errorText}</ErrorTextContainer>;\n        } else {\n            return <ErrorTextContainerPlaceholder />;\n        }\n    };\n\n    return <ErrorTextElement errorText={errorText} />;\n};\n\nexport default ErrorDisplay;\n","import React from 'react';\nimport Popup from 'reactjs-popup';\nimport styled from 'styled-components';\nimport { observer } from 'mobx-react';\nimport { useStores } from '../contexts/storesContext';\nimport { InputValidationStatus, SwapObjection } from '../stores/SwapForm';\nimport { formatPctString, bnum } from '../utils/helpers';\n\nconst SlippageInfoContainer = styled.div`\n    display: flex;\n    flex-direction: row;\n    justify-content: center;\n    color: ${props =>\n        props.slippageIndicator ? 'var(--error-color)' : 'var(--header-text)'};\n    font-family: var(--roboto);\n    font-size: 14px;\n    line-height: 16px;\n    display: flex;\n    align-items: center;\n    margin-bottom: 28px;\n`;\n\nconst SlippageInlineDisplay = styled.div`\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    width: 50px;\n    height: 24px;\n    border: 1px solid var(--link-text);\n    border-color: ${props =>\n        props.errorStatus === InputValidationStatus.VALID &&\n        !props.slippageIndicator\n            ? 'var(--link-text)'\n            : 'var(--error-color)'};\n    box-sizing: border-box;\n    border-radius: 4px;\n    margin-left: 10px;\n    margin-right: 10px;\n    color: ${props =>\n        props.errorStatus === InputValidationStatus.VALID &&\n        !props.slippageIndicator\n            ? 'var(--link-text)'\n            : 'var(--error-color)'};\n    cursor: pointer;\n`;\n\nconst InfoPopover = styled.img`\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    width: 15px;\n    height: 15px;\n    margin-left: 10px;\n    cursor: pointer;\n`;\n\nconst WarningIcon = styled.img`\n    width: 22px;\n    height: 26px;\n    margin-right: 11px;\n    color: var(--error-color);\n`;\n\nconst SlippageInfo = observer(() => {\n    const {\n        root: { swapFormStore },\n    } = useStores();\n    const {\n        inputs: { extraSlippageAllowance },\n        outputs: { expectedSlippage },\n        slippageSelectorOpen,\n    } = swapFormStore;\n\n    let slippageIndicator = false;\n\n    if (swapFormStore.outputs.swapObjection !== SwapObjection.NONE)\n        slippageIndicator = true;\n\n    if (expectedSlippage > '5') {\n        slippageIndicator = true;\n    }\n\n    const Warning = () => {\n        if (slippageIndicator) {\n            return <WarningIcon src=\"WarningSign.svg\" />;\n        } else {\n            return <div />;\n        }\n    };\n\n    const toggleDropDown = () => {\n        if (slippageSelectorOpen) {\n            return swapFormStore.setSlippageSelectorOpen(false);\n        } else {\n            return swapFormStore.setSlippageSelectorOpen(true);\n        }\n    };\n\n    return (\n        <SlippageInfoContainer slippageIndicator={slippageIndicator}>\n            {Warning()}\n            <div>\n                Expected price slippage of{' '}\n                {formatPctString(bnum(expectedSlippage))} with\n            </div>\n            <SlippageInlineDisplay\n                errorStatus={swapFormStore.getSlippageSelectorErrorStatus()}\n                slippageIndicator={slippageIndicator}\n                onClick={() => {\n                    toggleDropDown();\n                }}\n            >\n                {swapFormStore.getSlippageSelectorErrorStatus() ===\n                InputValidationStatus.VALID\n                    ? `${extraSlippageAllowance}%`\n                    : `-`}\n            </SlippageInlineDisplay>\n            <div>additional limit</div>\n            <Popup\n                trigger={<InfoPopover src=\"info.svg\" />}\n                position=\"top center\"\n                on=\"hover\"\n            >\n                <div>\n                    <div>\n                        Additional slippage is the most you are willing to pay\n                        on top of the expected slippage in case other trades are\n                        confirmed before yours. Beyond that the transaction will\n                        fail.\n                    </div>\n                </div>\n            </Popup>\n        </SlippageInfoContainer>\n    );\n});\n\nexport default SlippageInfo;\n","import React from 'react';\nimport styled from 'styled-components';\nimport { useStores } from '../contexts/storesContext';\nimport SlippageInfo from './SlippageInfo';\nimport { InputValidationStatus } from '../stores/SwapForm';\nimport { observer } from 'mobx-react';\n\nconst Container = styled.div`\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    margin-bottom: 32px;\n`;\n\nconst SelectorDropDown = styled.div`\n    display: flex;\n    flex-direction: row;\n    justify-content: center;\n    width: 500px;\n    height: 38px;\n    border-radius: 6px;\n    position: relative;\n`;\n\nconst SelectorDropDownCell = styled.div`\n    font-family: var(--roboto);\n    font-size: 14px;\n    line-height: 16px;\n    width: 125px;\n    display: flex;\n    position: relative;\n    background: var(--selector-background);\n    align-items: center;\n    justify-content: center;\n    color: var(--selector-text);\n    border: 1px solid var(--selector-border);\n    border-left: none;\n    :nth-child(1) {\n        border-left: 1px solid var(--selector-border);\n        border-radius: 6px 0px 0px 6px;\n    }\n    :nth-last-child(1) {\n        border-radius: 0px 6px 6px 0px;\n    }\n    cursor: pointer;\n    z-index: 1;\n`;\n\nconst ActiveSelectorDropDownCell = styled(SelectorDropDownCell)`\n    color: var(--highlighted-selector-text);\n    border: 1px solid var(--highlighted-selector-border);\n    background: var(--highlighted-selector-background);\n    margin-left: -1px;\n    :nth-child(1) {\n        border-left: 1px solid var(--highlighted-selector-border);\n    }\n`;\n\nconst Arrow = styled.div`\n    width: 12px;\n    height: 12px;\n    background: #7785d5;\n    transform: rotate(45deg);\n    position: absolute;\n    top: -6px;\n    right: 185px;\n    cursor: pointer;\n`;\n\nconst NumberInput = styled.input`\n    &::-webkit-inner-spin-button {\n        display: none;\n    }\n    -moz-appearance: textfield;\n`;\n\nconst InputWrapper = styled.div`\n    font-family: Roboto;\n    font-weight: 500;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    color: var(--body-text);\n    input {\n        width: 60%;\n        color: var(--body-text);\n        font-size: 16px;\n        line-height: 19px;\n        text-align: center;\n        background-color: var(--highlighted-selector-background);\n        border: none;\n        :-webkit-autofill,\n        :-webkit-autofill:hover,\n        :-webkit-autofill:focus,\n        :-webkit-autofill:active,\n        :-internal-autofill-selected {\n            -webkit-text-fill-color: var(--body-text);\n        }\n        :focus {\n            outline: none;\n        }\n    }\n`;\n\nconst SlippageSelector = observer(() => {\n    const {\n        root: { swapFormStore },\n    } = useStores();\n\n    const { slippageCell, slippageSelectorOpen } = swapFormStore;\n\n    const updateSlippage = (cellIndex, slippageValue) => {\n        swapFormStore.setSlippageCell(cellIndex);\n        swapFormStore.setExtraSlippageAllowance(slippageValue);\n        swapFormStore.setSlippageSelectorErrorStatus(\n            InputValidationStatus.VALID\n        );\n    };\n\n    const onChange = event => {\n        const { value } = event.target;\n\n        const inputStatus = swapFormStore.getNumberInputValidationStatus(\n            value,\n            {\n                limitDigits: true,\n            }\n        );\n\n        if (inputStatus === InputValidationStatus.VALID) {\n            swapFormStore.setExtraSlippageAllowance(value);\n        } else {\n            swapFormStore.setExtraSlippageAllowance('-');\n        }\n\n        swapFormStore.setSlippageSelectorErrorStatus(inputStatus);\n    };\n\n    const CellGenerator = ({ children, cellIndex, slippageValue }) => {\n        if (slippageCell === cellIndex) {\n            return (\n                <ActiveSelectorDropDownCell>\n                    {children}\n                </ActiveSelectorDropDownCell>\n            );\n        } else {\n            return (\n                <SelectorDropDownCell\n                    onClick={() => {\n                        updateSlippage(cellIndex, slippageValue);\n                    }}\n                >\n                    {children}\n                </SelectorDropDownCell>\n            );\n        }\n    };\n\n    const CustomCell = ({ cellIndex }) => {\n        if (slippageCell === cellIndex) {\n            return (\n                <ActiveSelectorDropDownCell>\n                    <InputWrapper>\n                        <NumberInput\n                            type=\"number\"\n                            placeholder=\"0\"\n                            defaultValue={\n                                swapFormStore.inputs.extraSlippageAllowance\n                            }\n                            onChange={e => onChange(e)}\n                        />\n                        %\n                    </InputWrapper>\n                </ActiveSelectorDropDownCell>\n            );\n        } else {\n            return (\n                <SelectorDropDownCell\n                    onClick={() => {\n                        swapFormStore.setSlippageCell(cellIndex);\n                    }}\n                >\n                    Custom %\n                </SelectorDropDownCell>\n            );\n        }\n    };\n\n    return (\n        <Container>\n            <SlippageInfo />\n            <SelectorDropDown\n                style={{ display: slippageSelectorOpen ? 'flex' : 'none' }}\n            >\n                <CellGenerator cellIndex=\"1\" slippageValue=\"0.1\">\n                    0.1%\n                </CellGenerator>\n                <CellGenerator cellIndex=\"2\" slippageValue=\"0.5\">\n                    0.5%\n                </CellGenerator>\n                <CellGenerator cellIndex=\"3\" slippageValue=\"1.0\">\n                    1.0%\n                </CellGenerator>\n                <Arrow\n                    onClick={() => {\n                        swapFormStore.setSlippageSelectorOpen(false);\n                    }}\n                />\n                <CustomCell cellIndex=\"4\" />\n            </SelectorDropDown>\n        </Container>\n    );\n});\n\nexport default SlippageSelector;\n","import React from 'react';\nimport styled from 'styled-components';\nimport {\n    normalizePriceValuesInput,\n    normalizePriceValuesOutput,\n    toAddressStub,\n    getEtherscanLink,\n} from 'utils/helpers';\nimport { observer } from 'mobx-react';\nimport { Pie } from 'react-chartjs-2';\nimport { ChartData } from '../stores/SwapForm';\nimport { useStores } from '../contexts/storesContext';\nimport { getSupportedChainId } from '../provider/connectors';\n\nconst Container = styled.div`\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    margin-top: 32px;\n    margin-bottom: 20px;\n`;\n\nconst Info = styled.div`\n    display: flex;\n    flex-direction: row;\n    justify-content: center;\n    font-family: var(--roboto);\n    font-size: 14px;\n    line-height: 20px;\n    color: var(--header-text);\n`;\n\nconst DropDownArrow = styled.div`\n    width: 20px;\n    height: 20px;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    margin-left: 12px;\n    cursor: pointer;\n`;\n\nconst OppositeArrows = styled.img`\n    height: 20px;\n    cursor: pointer;\n    transform: rotate(90deg);\n`;\n\nconst UpCarretIcon = styled.img`\n    height: 20px;\n`;\n\nconst DownCarretIcon = styled.img`\n    height: 20px;\n`;\n\nconst CompositionDropDown = styled.div`\n    width: 508px;\n    height: 170px;\n    display: flex;\n    flex-wrap: wrap;\n    align-items: center;\n    justify-content: center;\n    border: 1px solid var(--highlighted-selector-background);\n    margin-top: 18px;\n    border-radius: 6px;\n`;\n\nconst CompositionTitle = styled.div`\n    width: 315px;\n    display: flex;\n    color: var(--token-balance-text);\n    font-size: 12px;\n    flex-direction: row;\n    align-items: center;\n    justify-content: space-between;\n`;\n\nconst PoolLineContainer = styled.div`\n    display: flex;\n    flex-direction: column;\n    margin-right: 32px;\n`;\n\nconst PoolLine = styled.div`\n    height: 36px;\n    width: 315px;\n    display: flex;\n    flex-direction: row;\n    align-items: center;\n    justify-content: space-between;\n    font-family: var(--roboto);\n    font-size: 14px;\n    line-height: 16px;\n`;\n\nconst AddressAndBullet = styled.div`\n    display: flex;\n    flex-direction: row;\n    align-items: center;\n`;\n\nconst BulletPoint = styled.div`\n    width: 12px;\n    height: 12px;\n    background: ${props => props.color || '#A7FFEB'};\n    border-radius: 6px;\n`;\n\nconst Address = styled.div`\n    color: var(--selector-text);\n    margin-left: 16px;\n`;\n\nconst AddressLink = styled.a`\n    color: var(--selector-text);\n`;\n\nconst Percentage = styled.div`\n    color: var(--token-balance-text);\n`;\n\nconst PieChartWrapper = styled.div`\n    width: 96px;\n    height: 96px;\n`;\n\nconst Arrow = styled.div`\n    color: var(--highlighted-selector-background);\n    margin-left: 16px;\n    font-family: var(--roboto);\n    font-size: 20px;\n    font-weight: 900;\n`;\n\nconst TradeComposition = observer(() => {\n    const {\n        root: { swapFormStore },\n    } = useStores();\n\n    const supportedChainId = getSupportedChainId();\n    const chartData = swapFormStore.tradeCompositionData;\n    const { tradeCompositionOpen, exchangeRateInput } = swapFormStore;\n\n    const options = {\n        maintainAspectRatio: false,\n        legend: {\n            display: false,\n        },\n        tooltips: {\n            enabled: false,\n        },\n    };\n\n    const formatting = {\n        borderAlign: 'center',\n        backgroundColor: ['#A7FFEB', '#FF9E80', '#B388FF'],\n        borderColor: ['#A7FFEB', '#FF9E80', '#B388FF'],\n        borderWidth: '0',\n        weight: 95,\n    };\n\n    const formatPieData = (chartData: ChartData) => {\n        const pieData = {\n            datasets: [\n                {\n                    data: [1],\n                    label: 'swaps',\n                    borderAlign: 'center',\n                    borderColor: '#B388FF',\n                    borderWidth: '1',\n                    weight: 1,\n                },\n                {\n                    data: [],\n                    label: 'other',\n                    borderAlign: 'center',\n                    backgroundColor: ['#A7FFEB', '#FF9E80', '#B388FF'],\n                    borderColor: ['#A7FFEB', '#FF9E80', '#B388FF'],\n                    borderWidth: '0',\n                    weight: 95,\n                },\n            ],\n        };\n\n        if (chartData.validSwap) {\n            chartData.swaps.forEach(swap => {\n                pieData.datasets[1].data.push(swap.percentage);\n            });\n        }\n        return pieData;\n    };\n\n    const toggleDropDown = () => {\n        if (tradeCompositionOpen) {\n            return swapFormStore.setTradeCompositionOpen(false);\n        } else {\n            return swapFormStore.setTradeCompositionOpen(true);\n        }\n    };\n\n    const toggleExchangeRate = () => {\n        if (exchangeRateInput) {\n            return swapFormStore.setExchangeRateInput(false);\n        } else {\n            return swapFormStore.setExchangeRateInput(true);\n        }\n    };\n\n    const renderAddress = swap => {\n        if (swap.isOthers) {\n            return <Address>Others</Address>;\n        }\n        if (swap.noPools === 1) {\n            return (\n                <Address>\n                    <AddressLink\n                        href={getEtherscanLink(\n                            supportedChainId,\n                            swap.firstPoolAddress,\n                            'address'\n                        )}\n                        target=\"_blank\"\n                    >\n                        {toAddressStub(swap.firstPoolAddress)}\n                    </AddressLink>\n                </Address>\n            );\n        } else if (swap.noPools === 2) {\n            return (\n                <>\n                    <Address>\n                        <AddressLink\n                            href={getEtherscanLink(\n                                supportedChainId,\n                                swap.firstPoolAddress,\n                                'address'\n                            )}\n                            target=\"_blank\"\n                        >\n                            {toAddressStub(swap.firstPoolAddress)}\n                        </AddressLink>\n                    </Address>\n                    <Arrow>></Arrow>\n                    <Address>\n                        <AddressLink\n                            href={getEtherscanLink(\n                                supportedChainId,\n                                swap.secondPoolAddress,\n                                'address'\n                            )}\n                            target=\"_blank\"\n                        >\n                            {toAddressStub(swap.secondPoolAddress)}\n                        </AddressLink>\n                    </Address>\n                </>\n            );\n        }\n    };\n\n    const renderChartRows = (chartData: ChartData, formatting) => {\n        if (chartData.validSwap) {\n            return chartData.swaps.map((swap, index) => {\n                return (\n                    <PoolLine key={index}>\n                        <AddressAndBullet>\n                            <BulletPoint\n                                color={formatting.borderColor[index]}\n                            />\n\n                            {renderAddress(swap)}\n                        </AddressAndBullet>\n                        <Percentage>{swap.percentage}%</Percentage>\n                    </PoolLine>\n                );\n            });\n        }\n\n        return (\n            <PoolLine>\n                <AddressAndBullet>\n                    <BulletPoint color={formatting.borderColor[0]} />\n                    <Address>Please input a valid swap</Address>\n                </AddressAndBullet>\n            </PoolLine>\n        );\n    };\n\n    const renderExchangeRate = (chartData: ChartData) => {\n        const inputTokenData = swapFormStore.inputToken;\n        const outputTokenData = swapFormStore.outputToken;\n\n        if (chartData.validSwap) {\n            if (exchangeRateInput) {\n                const {\n                    normalizedInput,\n                    normalizedOutput,\n                } = normalizePriceValuesInput(\n                    chartData.inputPriceValue,\n                    inputTokenData.decimals,\n                    chartData.outputPriceValue,\n                    outputTokenData.decimals\n                );\n\n                return (\n                    <div>\n                        {normalizedInput.toString()} {inputTokenData.symbol} ={' '}\n                        {normalizedOutput.toPrecision(6)}{' '}\n                        {outputTokenData.symbol}\n                    </div>\n                );\n            } else {\n                const {\n                    normalizedInput,\n                    normalizedOutput,\n                } = normalizePriceValuesOutput(\n                    chartData.inputPriceValue,\n                    inputTokenData.decimals,\n                    chartData.outputPriceValue,\n                    outputTokenData.decimals\n                );\n\n                return (\n                    <div>\n                        {normalizedInput.toString()} {outputTokenData.symbol} ={' '}\n                        {normalizedOutput.toPrecision(6)}{' '}\n                        {inputTokenData.symbol}\n                    </div>\n                );\n            }\n        } else {\n            return <div>Input swap parameters</div>;\n        }\n    };\n\n    return (\n        <Container>\n            <Info>\n                <OppositeArrows\n                    src=\"swap.svg\"\n                    onClick={() => {\n                        toggleExchangeRate();\n                    }}\n                />\n                {renderExchangeRate(chartData)}\n                <DropDownArrow\n                    onClick={() => {\n                        toggleDropDown();\n                    }}\n                >\n                    <UpCarretIcon\n                        src=\"arrow-bottom.svg\"\n                        style={{\n                            display: tradeCompositionOpen ? 'block' : 'none',\n                        }}\n                    />\n                    <DownCarretIcon\n                        src=\"dropdown.svg\"\n                        style={{\n                            display: tradeCompositionOpen ? 'none' : 'block',\n                        }}\n                    />\n                </DropDownArrow>\n            </Info>\n            <CompositionDropDown\n                style={{ display: tradeCompositionOpen ? 'flex' : 'none' }}\n            >\n                <CompositionTitle>\n                    Your order has been optimized using {chartData.noPools}{' '}\n                    Balancer pool{chartData.noPools > 1 ? 's' : ''} \n                </CompositionTitle>\n                <PoolLineContainer>\n                    {renderChartRows(chartData, formatting)}\n                </PoolLineContainer>\n                <PieChartWrapper>\n                    <Pie data={formatPieData(chartData)} options={options} />\n                </PieChartWrapper>\n            </CompositionDropDown>\n        </Container>\n    );\n});\n\nexport default TradeComposition;\n","import React, { useEffect } from 'react';\nimport styled from 'styled-components';\nimport { TokenIconAddress } from './TokenPanel';\nimport { useStores } from '../contexts/storesContext';\nimport { bnum, formatBalanceTruncated, isEmpty } from 'utils/helpers';\nimport { isChainIdSupported } from '../provider/connectors';\nimport { observer } from 'mobx-react';\n\nconst AssetPanelContainer = styled.div`\n    display: flex;\n    flex-direction: row;\n    flex-wrap: wrap;\n    justify-content: flex-start;\n    max-height: 329px;\n    overflow: auto; /* Enable scroll if needed */\n    ::-webkit-scrollbar {\n        display: none;\n    }\n`;\n\nconst AssetPanel = styled.div`\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    flex-direction: column;\n    width: 184px;\n    height: 98px;\n    cursor: pointer;\n    border-right: 1px solid var(--panel-border);\n    border-bottom: 1px solid var(--panel-border);\n    :nth-child(3n + 3) {\n        border-right: none;\n    }\n`;\n\nconst AssetWrapper = styled.div`\n    display: flex;\n    flex-direction: row;\n    font-family: Roboto;\n    font-style: normal;\n    font-weight: normal;\n`;\n\nconst TokenIcon = styled.img`\n    width: 28px;\n    height: 28px;\n    margin-right: 12px;\n`;\n\nconst TokenName = styled.div`\n    font-size: 16px;\n    line-height: 19px;\n    display: flex;\n    align-items: center;\n`;\n\nconst TokenBalance = styled.div`\n    font-size: 14px;\n    line-height: 16px;\n    display: flex;\n    align-items: center;\n    text-align: center;\n    color: var(--body-text);\n    margin-top: 12px;\n`;\n\nconst NoPool = styled.div`\n    margin-left: 5px;\n    color: var(--error-color);\n`;\n\nconst ErrorLabel = styled.div`\n    margin-left: 5px;\n    color: var(--error-color);\n`;\n\ninterface Asset {\n    address: string;\n    symbol: string;\n    name: string;\n    hasIcon: boolean;\n    userBalance: string;\n    isTradable: boolean;\n}\n\nconst AssetOptions = observer(() => {\n    // TODO do math and pass props into AssetPanel css to make border-bottom none for bottom row of assets\n\n    const {\n        root: {\n            providerStore,\n            contractMetadataStore,\n            swapFormStore,\n            tokenStore,\n            poolStore,\n            assetOptionsStore,\n        },\n    } = useStores();\n\n    const account = providerStore.providerStatus.account;\n    const chainId = providerStore.providerStatus.activeChainId;\n\n    const { assetSelectFilter, assetModalState } = swapFormStore;\n\n    useEffect(() => {\n        if (!isEmpty(assetSelectFilter))\n            assetOptionsStore.fetchTokenAssetData(assetSelectFilter, account);\n    }, [assetSelectFilter, account, assetOptionsStore]); // Only re-run the effect on token address change\n\n    const getAssetOptions = (filter, account): Asset[] => {\n        const filteredWhitelistedTokens = contractMetadataStore.getFilteredTokenMetadata(\n            filter\n        );\n        // filteredWhitelistedTokens.forEach(token => console.log(token))\n\n        let assetSelectorData: Asset[] = [];\n        let userBalances = {};\n        let tradableTokens;\n\n        if (assetModalState.input === 'inputAmount') {\n            tradableTokens = poolStore.getTokenPairs(\n                swapFormStore.outputToken.address\n            );\n        } else if (assetModalState.input === 'outputAmount') {\n            tradableTokens = poolStore.getTokenPairs(\n                swapFormStore.inputToken.address\n            );\n        }\n\n        if (account && isChainIdSupported(chainId)) {\n            userBalances = tokenStore.getAccountBalances(\n                filteredWhitelistedTokens,\n                account\n            );\n        }\n\n        assetSelectorData = filteredWhitelistedTokens.map(value => {\n            const userBalance = formatBalanceTruncated(\n                userBalances[value.address]\n                    ? bnum(userBalances[value.address])\n                    : bnum(0),\n                value.decimals,\n                value.precision,\n                20\n            );\n\n            return {\n                address: value.address,\n                symbol: value.symbol,\n                name: value.name,\n                hasIcon: value.hasIcon,\n                userBalance: userBalance,\n                isTradable: tradableTokens\n                    ? tradableTokens.has(value.address)\n                    : false,\n            };\n        });\n\n        return assetSelectorData;\n    };\n\n    const sortAssetOptions = (assets: Asset[], account) => {\n        const manualToken = assetOptionsStore.tokenAssetData;\n\n        if (manualToken) {\n            if (\n                !assets.find(\n                    asset =>\n                        asset.address.toLowerCase() ===\n                        manualToken.address.toLowerCase()\n                )\n            ) {\n                assets.push(manualToken);\n            }\n        }\n\n        const buckets = {\n            tradableWithBalance: [] as Asset[],\n            tradableWithoutBalance: [] as Asset[],\n            notTradableWithBalance: [] as Asset[],\n            notTradableWithoutBalance: [] as Asset[],\n        };\n        assets.forEach(asset => {\n            const isTradable = asset.isTradable;\n            const hasBalance = account && bnum(asset.userBalance).gt(0);\n\n            if (isTradable && hasBalance) {\n                buckets.tradableWithBalance.push(asset);\n            } else if (isTradable && !hasBalance) {\n                buckets.tradableWithoutBalance.push(asset);\n            } else if (!isTradable && hasBalance) {\n                buckets.notTradableWithBalance.push(asset);\n            } else if (!isTradable && !hasBalance) {\n                buckets.notTradableWithoutBalance.push(asset);\n            }\n        });\n\n        // We don't introduce a possibility of duplicates and therefore don't need to use Set\n        return [\n            ...buckets.tradableWithBalance,\n            ...buckets.tradableWithoutBalance,\n            ...buckets.notTradableWithBalance,\n            ...buckets.notTradableWithoutBalance,\n        ];\n    };\n\n    const assets = sortAssetOptions(\n        getAssetOptions(assetSelectFilter, account),\n        account\n    );\n\n    const clearInputs = () => {\n        swapFormStore.inputs.inputAmount = '';\n        swapFormStore.inputs.outputAmount = '';\n        swapFormStore.clearErrorMessage();\n        swapFormStore.clearTradeComposition();\n    };\n\n    const selectAsset = token => {\n        if (isUntrustedToken(token.address)) {\n            return;\n        }\n        if (assetModalState.input === 'inputAmount') {\n            swapFormStore.setSelectedInputTokenMetaData(token.address, account);\n        } else {\n            swapFormStore.setSelectedOutputTokenMetaData(\n                token.address,\n                account\n            );\n        }\n        clearInputs();\n        swapFormStore.setAssetModalState({ open: false });\n    };\n\n    const isUntrustedToken = (address): boolean => {\n        const untrustedTokens = contractMetadataStore.getUntrustedTokens();\n        return untrustedTokens.includes(address);\n    };\n\n    const TradableToken = ({ isTradable }) => {\n        if (isTradable) {\n            return <div />;\n        } else {\n            return <NoPool>No Pool</NoPool>;\n        }\n    };\n\n    const IconError = e => {\n        e.target.src = './empty-token.png';\n    };\n\n    return (\n        <AssetPanelContainer>\n            {assets.map(token => (\n                <AssetPanel\n                    onClick={() => {\n                        selectAsset(token);\n                    }}\n                    key={token.address}\n                >\n                    <AssetWrapper>\n                        <TokenIcon\n                            src={TokenIconAddress(token.address, token.hasIcon)}\n                            onError={e => {\n                                IconError(e);\n                            }}\n                        />\n                        <TokenName>{token.symbol}</TokenName>\n                    </AssetWrapper>\n                    <TokenBalance>\n                        {token.userBalance + ' ' + token.symbol}\n                        <TradableToken isTradable={token.isTradable} />\n                        {isUntrustedToken(token.address) ? (\n                            <ErrorLabel>Bad ERC20</ErrorLabel>\n                        ) : (\n                            <div />\n                        )}\n                    </TokenBalance>\n                </AssetPanel>\n            ))}\n        </AssetPanelContainer>\n    );\n});\n\nexport default AssetOptions;\n","import React, { useEffect, useRef } from 'react';\nimport styled from 'styled-components';\nimport AssetOptions from './AssetOptions';\nimport { observer } from 'mobx-react';\nimport { useStores } from '../contexts/storesContext';\n\nconst Container = styled.div`\n    display: block;\n    position: fixed;\n    z-index: 5;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    overflow: auto; /* Enable scroll if needed */\n    background-color: rgb(0, 0, 0);\n    background-color: rgba(0, 0, 0, 0.4); /* Black w/ opacity */\n`;\n\nconst ModalContent = styled.div`\n    margin: 15% auto;\n    display: flex;\n    flex-direction: column;\n    max-width: 554px;\n    max-height: 449px;\n    background-color: var(--panel-background);\n    border: 1px solid var(--panel-border);\n    border-radius: 4px;\n    color: white;\n`;\n\nconst AssetSelectorHeader = styled.div`\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    height: 68px;\n    padding: 0px 20px;\n    background-color: var(--panel-header-background);\n    color: var(--header-text);\n    border-radius: 4px;\n    border-bottom: 1px solid var(--panel-border);\n`;\n\nconst HeaderContent = styled.div``;\n\nconst ExitComponent = styled.div`\n    color: var(--exit-modal-color);\n    transform: rotate(135deg);\n    font-size: 22px;\n    cursor: pointer;\n`;\n\nconst InputContainer = styled.div`\n    display: flex;\n    align-items: center;\n    height: 60px;\n    padding: 0px 20px;\n    justify-content: space-between;\n    color: var(--body-text);\n    padding-left: 21px;\n    padding-right: 21px;\n    border-bottom: 1px solid var(--panel-border);\n    input {\n        width: 75%;\n        color: var(--body-text);\n        font-size: 16px;\n        line-height: 19px;\n        background-color: var(--panel-background);\n        border: none;\n        box-shadow: inset 0 0 0 1px var(--panel-background),\n            inset 0 0 0 100px var(--panel-background);\n        :-webkit-autofill,\n        :-webkit-autofill:hover,\n        :-webkit-autofill:focus,\n        :-webkit-autofill:active,\n        :-internal-autofill-selected {\n            -webkit-text-fill-color: var(--body-text);\n        }\n        :focus {\n            outline: none;\n        }\n    }\n`;\n\nfunction useOnClickOutside(ref, handler) {\n    useEffect(() => {\n        const handleClick = event => {\n            // Do nothing if clicking ref's element or descendent elements\n            if (!ref.current || ref.current.contains(event.target)) {\n                return;\n            }\n\n            handler(event);\n        };\n\n        const handleKeyUp = event => {\n            if (event.key !== 'Escape') {\n                return;\n            }\n            handler(event);\n        };\n\n        document.addEventListener('mousedown', handleClick);\n        window.addEventListener('keydown', handleKeyUp, false);\n        document.addEventListener('touchstart', handleClick);\n\n        return () => {\n            document.removeEventListener('mousedown', handleClick);\n            window.removeEventListener('keydown', handleKeyUp, false);\n            document.removeEventListener('touchstart', handleClick);\n        };\n    }, [ref, handler]);\n}\n\nconst AssetSelector = observer(() => {\n    const {\n        root: { swapFormStore },\n    } = useStores();\n\n    const ref = useRef();\n    const inputRef = useRef(null);\n\n    useEffect(() => {\n        if (inputRef !== null) inputRef.current.focus();\n    });\n\n    useOnClickOutside(ref, () =>\n        swapFormStore.setAssetModalState({ open: false })\n    );\n\n    const { assetModalState } = swapFormStore;\n\n    const onChange = async event => {\n        swapFormStore.setAssetSelectFilter(event.target.value);\n    };\n\n    return (\n        <Container style={{ display: assetModalState.open ? 'block' : 'none' }}>\n            <ModalContent ref={ref}>\n                <AssetSelectorHeader>\n                    <HeaderContent>\n                        Select Token to{' '}\n                        {assetModalState.input === 'inputAmount'\n                            ? `Sell for ${swapFormStore.outputToken.symbol}`\n                            : `Buy with ${swapFormStore.inputToken.symbol}`}\n                    </HeaderContent>\n                    <ExitComponent\n                        onClick={() => {\n                            swapFormStore.setAssetModalState({ open: false });\n                        }}\n                    >\n                        +\n                    </ExitComponent>\n                </AssetSelectorHeader>\n                <InputContainer>\n                    <input\n                        onChange={e => onChange(e)}\n                        placeholder=\"Search Token Name, Symbol, or Address\"\n                        ref={inputRef}\n                    />\n                </InputContainer>\n                <AssetOptions />\n            </ModalContent>\n        </Container>\n    );\n});\n\nexport default AssetSelector;\n","import React, { useEffect } from 'react';\nimport styled from 'styled-components';\nimport BuyToken from './BuyToken';\nimport SellToken from './SellToken';\nimport Switch from './Switch';\nimport Button from './Button';\nimport ErrorDisplay from './ErrorDisplay';\nimport SlippageSelector from './SlippageSelector';\nimport TradeComposition from './TradeComposition';\nimport AssetSelector from './AssetSelector';\n\nimport { observer } from 'mobx-react';\nimport { bnum, scale, isEmpty } from 'utils/helpers';\nimport { SwapMethods, SwapObjection } from 'stores/SwapForm';\nimport { useStores } from '../contexts/storesContext';\nimport { ErrorIds } from '../stores/Error';\nimport { BigNumber } from 'utils/bignumber';\nimport { getSupportedChainId } from '../provider/connectors';\nimport {\n    ExactAmountInPreview,\n    ExactAmountOutPreview,\n    calcMaxAmountIn,\n    calcMinAmountOut,\n} from '../stores/Proxy';\n\nconst RowContainer = styled.div`\n    font-family: var(--roboto);\n    display: flex;\n    flex-direction: row;\n    align-items: center;\n    justify-content: center;\n`;\n\nconst ColumnContainer = styled.div`\n    font-family: var(--roboto);\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n`;\n\nconst MessageBlock = styled.div`\n    font-family: var(--roboto);\n    font-size: 14px;\n    line-height: 16px;\n    display: flex;\n    align-items: center;\n    color: var(--header-text);\n    text-align: center;\n    margin-top: 6px;\n    margin-bottom: 36px;\n`;\n\nconst TradeCompositionPlaceholder = styled.div`\n    height: 72px;\n`;\n\nconst SlippageSelectorPlaceholder = styled.div`\n    height: 84px;\n`;\n\nenum ButtonState {\n    NO_WALLET,\n    UNLOCK,\n    SWAP,\n}\n\nconst ButtonText = ['Connect Wallet', 'Unlock', 'Swap'];\n\nconst SwapForm = observer(({ tokenIn, tokenOut }) => {\n    const {\n        root: {\n            proxyStore,\n            contractMetadataStore,\n            swapFormStore,\n            providerStore,\n            tokenStore,\n            errorStore,\n            dropdownStore,\n        },\n    } = useStores();\n\n    const supportedChainId = getSupportedChainId();\n    const account = providerStore.providerStatus.account;\n    const chainId = getSupportedChainId();\n\n    if (!chainId) {\n        // Review error message\n        throw new Error('ChainId not loaded in TestPanel');\n    }\n\n    useEffect(() => {\n        if (tokenIn) {\n            console.log(`[SwapForm] Using Input Token From URL: ${tokenIn}`);\n            swapFormStore.setInputAddress(tokenIn);\n        }\n\n        if (tokenOut) {\n            console.log(`[SwapForm] Using Output Token From URL: ${tokenOut}`);\n            swapFormStore.setOutputAddress(tokenOut);\n        }\n    }, [tokenIn, tokenOut, swapFormStore, account]); // Only re-run the effect on token address change\n\n    // This loads all the token data after selection\n    const inputAddress = swapFormStore.inputToken.address;\n    useEffect(() => {\n        if (inputAddress !== '') {\n            console.log(`[SwapForm] Setting Input Token ${inputAddress}`);\n            swapFormStore.setSelectedInputToken(inputAddress, account);\n        }\n    }, [inputAddress, account, swapFormStore]); // Only re-run the effect on token address change\n\n    // This loads all the token data after selection\n    const outputAddress = swapFormStore.outputToken.address;\n    useEffect(() => {\n        if (outputAddress !== '') {\n            console.log(`[SwapForm] Setting Output Token ${outputAddress}`);\n            swapFormStore.setSelectedOutputToken(outputAddress, account);\n        }\n    }, [outputAddress, account, swapFormStore]); // Only re-run the effect on token address change\n\n    const buttonActionHandler = (buttonState: ButtonState) => {\n        switch (buttonState) {\n            case ButtonState.NO_WALLET:\n                dropdownStore.toggleWalletDropdown();\n                break;\n            case ButtonState.SWAP:\n                swapHandler();\n                break;\n            case ButtonState.UNLOCK:\n                unlockHandler();\n                break;\n            default:\n                throw new Error('Invalid button state');\n        }\n    };\n\n    const unlockHandler = async () => {\n        const tokenToUnlock = swapFormStore.inputToken.address;\n        const proxyAddress = contractMetadataStore.getProxyAddress();\n        await tokenStore.approveMax(tokenToUnlock, proxyAddress);\n    };\n\n    const swapHandler = async () => {\n        // Don't attempt Swap if preview is in progress - we don't change the UI while it's loading and hope it resolves near immediately\n        if (proxyStore.isPreviewPending()) {\n            return;\n        }\n\n        if (swapFormStore.inputs.swapMethod === SwapMethods.EXACT_IN) {\n            const {\n                inputAmount,\n                extraSlippageAllowance,\n            } = swapFormStore.inputs;\n\n            const {\n                spotOutput,\n                expectedSlippage,\n                swaps,\n            } = swapFormStore.preview as ExactAmountInPreview;\n\n            const minAmountOut = calcMinAmountOut(\n                spotOutput,\n                expectedSlippage.plus(bnum(extraSlippageAllowance))\n            );\n\n            await proxyStore.batchSwapExactIn(\n                swaps,\n                swapFormStore.inputToken.address,\n                bnum(inputAmount),\n                swapFormStore.inputToken.decimals,\n                swapFormStore.outputToken.address,\n                bnum(minAmountOut),\n                swapFormStore.outputToken.decimals\n            );\n        } else if (swapFormStore.inputs.swapMethod === SwapMethods.EXACT_OUT) {\n            const {\n                outputAmount,\n                extraSlippageAllowance,\n            } = swapFormStore.inputs;\n\n            const {\n                spotInput,\n                expectedSlippage,\n                swaps,\n                totalInput,\n            } = swapFormStore.preview as ExactAmountOutPreview;\n\n            const maxAmountIn = calcMaxAmountIn(\n                spotInput,\n                expectedSlippage.plus(extraSlippageAllowance)\n            );\n\n            let maxIn = maxAmountIn.gt(totalInput) ? maxAmountIn : totalInput;\n\n            await proxyStore.batchSwapExactOut(\n                swaps,\n                swapFormStore.inputToken.address,\n                maxIn, //totalInput, //maxAmountIn,\n                swapFormStore.inputToken.decimals,\n                swapFormStore.outputToken.address,\n                bnum(outputAmount),\n                swapFormStore.outputToken.decimals\n            );\n        }\n    };\n\n    const getButtonState = (\n        account,\n        userAllowance: BigNumber | undefined\n    ): ButtonState => {\n        const sufficientAllowance = userAllowance && userAllowance.gt(0);\n        const chainId = providerStore.providerStatus.activeChainId;\n        if (chainId && chainId !== supportedChainId) {\n            return ButtonState.SWAP;\n        }\n\n        if (account) {\n            if (!sufficientAllowance) {\n                return ButtonState.UNLOCK;\n            }\n            return ButtonState.SWAP;\n        }\n\n        return ButtonState.NO_WALLET;\n    };\n\n    const getButtonText = (buttonState: ButtonState): string => {\n        return ButtonText[buttonState];\n    };\n\n    const getButtonActive = (\n        buttonState: ButtonState,\n        inputBalance: BigNumber | undefined\n    ): boolean => {\n        const isInputValid = swapFormStore.isValidInput(\n            swapFormStore.inputs.inputAmount\n        );\n        const isExtraSlippageAmountValid = swapFormStore.isValidStatus(\n            swapFormStore.inputs.extraSlippageAllowanceErrorStatus\n        );\n\n        const isPreviewValid =\n            swapFormStore.preview && !swapFormStore.preview.error;\n\n        const areInputOutputTokensEqual =\n            swapFormStore.inputToken.address ===\n                swapFormStore.outputToken.address ||\n            (swapFormStore.inputToken.address === 'ether' &&\n                swapFormStore.outputToken.address ===\n                    contractMetadataStore.getWethAddress()) ||\n            (swapFormStore.inputToken.address ===\n                contractMetadataStore.getWethAddress() &&\n                swapFormStore.outputToken.address === 'ether');\n\n        if (\n            buttonState === ButtonState.UNLOCK ||\n            buttonState === ButtonState.NO_WALLET\n        ) {\n            return true;\n        }\n\n        if (buttonState === ButtonState.SWAP) {\n            if (\n                isInputValid &&\n                isExtraSlippageAmountValid &&\n                chainId &&\n                isPreviewValid &&\n                !areInputOutputTokensEqual &&\n                chainId === supportedChainId\n            ) {\n                const inputAmountBN = scale(\n                    bnum(swapFormStore.inputs.inputAmount),\n                    swapFormStore.inputToken.decimals\n                );\n                return inputBalance && inputBalance.gte(inputAmountBN);\n            }\n        }\n\n        return false;\n    };\n\n    let userAllowance = swapFormStore.inputToken.allowance;\n\n    const buttonState = getButtonState(account, userAllowance);\n\n    // TODO Pull validation errors and errors in errorStore together; maybe handle a stack of active errors\n    const error = errorStore.getActiveError(ErrorIds.SWAP_FORM_STORE);\n    if (error) {\n        console.error('error', error);\n    }\n    const errorMessage = swapFormStore.outputs.activeErrorMessage;\n    const swapObjection = swapFormStore.outputs.swapObjection;\n\n    const renderMessageBlock = () => {\n        if (!isEmpty(errorMessage)) {\n            return <ErrorDisplay errorText={errorMessage} />;\n        } else {\n            return <MessageBlock>Enter Order Details to Continue</MessageBlock>;\n        }\n    };\n\n    const renderTradeDetails = (inputAmount, outputAmount) => {\n        // If we have an error from the input validation or swap preview\n        if (\n            (isEmpty(inputAmount) && isEmpty(outputAmount)) ||\n            !isEmpty(errorMessage)\n        ) {\n            return (\n                <ColumnContainer>\n                    <TradeCompositionPlaceholder />\n                    {renderMessageBlock()}\n                    <SlippageSelectorPlaceholder />\n                    <Button\n                        buttonText={getButtonText(buttonState)}\n                        active={getButtonActive(\n                            buttonState,\n                            swapFormStore.inputToken.balanceBn\n                        )}\n                        onClick={() => {\n                            buttonActionHandler(buttonState);\n                        }}\n                    />\n                </ColumnContainer>\n            );\n        } else {\n            return (\n                <ColumnContainer>\n                    <TradeComposition />\n                    <ErrorDisplay\n                        errorText={\n                            swapObjection === SwapObjection.NONE\n                                ? ''\n                                : swapObjection\n                        }\n                    />\n                    <SlippageSelector />\n                    <Button\n                        buttonText={getButtonText(buttonState)}\n                        active={getButtonActive(\n                            buttonState,\n                            swapFormStore.inputToken.balanceBn\n                        )}\n                        onClick={() => {\n                            buttonActionHandler(buttonState);\n                        }}\n                    />\n                </ColumnContainer>\n            );\n        }\n    };\n\n    return (\n        <div>\n            <AssetSelector />\n            <RowContainer>\n                <SellToken\n                    inputName=\"inputAmount\"\n                    tokenSymbol={swapFormStore.inputToken.symbol}\n                    tokenName={swapFormStore.inputToken.name}\n                    tokenBalance={swapFormStore.inputToken.balanceFormatted}\n                    truncatedTokenBalance={\n                        swapFormStore.inputToken.balanceFormatted\n                    }\n                    tokenAddress={swapFormStore.inputToken.address}\n                    tokenHasIcon={swapFormStore.inputToken.hasIcon}\n                    errorMessage={errorMessage}\n                    showMax={!!account && !!swapFormStore.inputToken.balanceBn}\n                />\n                <Switch />\n                <BuyToken\n                    inputName=\"outputAmount\"\n                    tokenSymbol={swapFormStore.outputToken.symbol}\n                    tokenName={swapFormStore.outputToken.name}\n                    tokenBalance={swapFormStore.outputToken.balanceFormatted}\n                    truncatedTokenBalance={\n                        swapFormStore.outputToken.balanceFormatted\n                    }\n                    tokenAddress={swapFormStore.outputToken.address}\n                    tokenHasIcon={swapFormStore.outputToken.hasIcon}\n                    errorMessage={errorMessage}\n                    showMax={!!account && !!swapFormStore.outputToken.balanceBn}\n                />\n            </RowContainer>\n            {renderTradeDetails(\n                swapFormStore.inputs.inputAmount,\n                swapFormStore.inputs.outputAmount\n            )}\n        </div>\n    );\n});\n\nexport default SwapForm;\n","import React from 'react';\nimport { HashRouter, Redirect, Route, Switch } from 'react-router-dom';\nimport styled from 'styled-components';\nimport Web3ReactManager from 'components/Web3ReactManager';\nimport Header from 'components/Header';\nimport GeneralNotification from 'components/GeneralNotification';\nimport SwapForm from 'components/SwapForm';\nimport { isAddress, toChecksum } from 'utils/helpers';\nimport './App.css';\n\nconst BuildVersion = styled.div`\n    display: flex;\n    flex-direction: row;\n    text-align: center;\n    margin: 20px;\n    font-size: 10px;\n    color: var(--body-text);\n    position: fixed;\n    bottom: 0px;\n    @media screen and (max-width: 1024px) {\n        display: none;\n    }\n`;\n\nconst BuildLink = styled.a`\n    color: var(--body-text);\n    text-decoration: none;\n    margin-left: 5px;\n`;\n\nconst App = () => {\n    const PoolSwapView = props => {\n        let { tokenIn, tokenOut } = props.match.params;\n        if (isAddress(tokenIn)) {\n            tokenIn = toChecksum(tokenIn);\n        }\n        if (isAddress(tokenOut)) {\n            tokenOut = toChecksum(tokenOut);\n        }\n\n        return <SwapForm tokenIn={tokenIn} tokenOut={tokenOut} />;\n    };\n\n    const buildId = process.env.REACT_APP_COMMIT_REF || '';\n\n    const renderViews = () => {\n        return (\n            <div className=\"app-shell\">\n                <Switch>\n                    <Route\n                        path=\"/swap/:tokenIn?/:tokenOut?\"\n                        component={PoolSwapView}\n                    />\n                    <Redirect from=\"/\" to=\"/swap\" />\n                </Switch>\n            </div>\n        );\n    };\n\n    return (\n        <Web3ReactManager>\n            <HashRouter>\n                <Header />\n                <GeneralNotification />\n                {renderViews()}\n                <BuildVersion>\n                    BUILD ID:{' '}\n                    <BuildLink\n                        href={`https://github.com/balancer-labs/balancer-exchange/tree/${buildId}`}\n                        target=\"_blank\"\n                    >\n                        {buildId.substring(0, 12)}\n                    </BuildLink>\n                </BuildVersion>\n            </HashRouter>\n        </Web3ReactManager>\n    );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n    window.location.hostname === 'localhost' ||\n        // [::1] is the IPv6 localhost address.\n        window.location.hostname === '[::1]' ||\n        // 127.0.0.1/8 is considered localhost for IPv4.\n        window.location.hostname.match(\n            /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n        )\n);\n\nexport function register(config) {\n    if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n        // The URL constructor is available in all browsers that support SW.\n        const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n        if (publicUrl.origin !== window.location.origin) {\n            // Our service worker won't work if PUBLIC_URL is on a different origin\n            // from what our page is served on. This might happen if a CDN is used to\n            // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n            return;\n        }\n\n        window.addEventListener('load', () => {\n            const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n            if (isLocalhost) {\n                // This is running on localhost. Let's check if a service worker still exists or not.\n                checkValidServiceWorker(swUrl, config);\n\n                // Add some additional logging to localhost, pointing developers to the\n                // service worker/PWA documentation.\n                navigator.serviceWorker.ready.then(() => {\n                    console.log(\n                        'This web app is being served cache-first by a service ' +\n                            'worker. To learn more, visit https://bit.ly/CRA-PWA'\n                    );\n                });\n            } else {\n                // Is not localhost. Just register service worker\n                registerValidSW(swUrl, config);\n            }\n        });\n    }\n}\n\nfunction registerValidSW(swUrl, config) {\n    navigator.serviceWorker\n        .register(swUrl)\n        .then(registration => {\n            registration.onupdatefound = () => {\n                const installingWorker = registration.installing;\n                if (installingWorker == null) {\n                    return;\n                }\n                installingWorker.onstatechange = () => {\n                    if (installingWorker.state === 'installed') {\n                        if (navigator.serviceWorker.controller) {\n                            // At this point, the updated precached content has been fetched,\n                            // but the previous service worker will still serve the older\n                            // content until all client tabs are closed.\n                            console.log(\n                                'New content is available and will be used when all ' +\n                                    'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n                            );\n\n                            // Execute callback\n                            if (config && config.onUpdate) {\n                                config.onUpdate(registration);\n                            }\n                        } else {\n                            // At this point, everything has been precached.\n                            // It's the perfect time to display a\n                            // \"Content is cached for offline use.\" message.\n                            console.log('Content is cached for offline use.');\n\n                            // Execute callback\n                            if (config && config.onSuccess) {\n                                config.onSuccess(registration);\n                            }\n                        }\n                    }\n                };\n            };\n        })\n        .catch(error => {\n            console.error('Error during service worker registration:', error);\n        });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n    // Check if the service worker can be found. If it can't reload the page.\n    fetch(swUrl)\n        .then(response => {\n            // Ensure service worker exists, and that we really are getting a JS file.\n            const contentType = response.headers.get('content-type');\n            if (\n                response.status === 404 ||\n                (contentType != null &&\n                    contentType.indexOf('javascript') === -1)\n            ) {\n                // No service worker found. Probably a different app. Reload the page.\n                navigator.serviceWorker.ready.then(registration => {\n                    registration.unregister().then(() => {\n                        window.location.reload();\n                    });\n                });\n            } else {\n                // Service worker found. Proceed as normal.\n                registerValidSW(swUrl, config);\n            }\n        })\n        .catch(() => {\n            console.log(\n                'No internet connection found. App is running in offline mode.'\n            );\n        });\n}\n\nexport function unregister() {\n    if ('serviceWorker' in navigator) {\n        navigator.serviceWorker.ready.then(registration => {\n            registration.unregister();\n        });\n    }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport 'index.css';\nimport App from 'App';\nimport * as serviceWorker from './serviceWorker';\n\nconst Root = (\n    <>\n        <App />\n    </>\n);\nReactDOM.render(Root, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","module.exports = __webpack_public_path__ + \"static/media/circle.2d975615.svg\";"],"sourceRoot":""}